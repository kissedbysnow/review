## 一、引论

|        |                                    |
| ------ | ---------------------------------- |
| 宿主机 | 运行编译程序的计算机               |
| 目标机 | 运行编译程序所产生目标代码的计算机 |

小结：

1. 语言程序分为：**汇编**语言程序和**高级**语言程序
2. 高级语言处理程序按翻译方式分为：**编译**程序和**解释**程序，区别：是否生成目标代码
3. 编译程序是这样一种程序，把源语言程序转化成目标语言程序

## 二、高级语言及其语法描述

### 2.1 上下文无关文法

|              |                                    |
| ------------ | ---------------------------------- |
| 文法         | 描述语言的语法结构的形式规则       |
| 上下文无关法 | 定义的语法范畴完全独立于出现的环境 |

上下文无关文法 G = ( VT，VN，S，P )

|      |                      |                                  |
| ---- | -------------------- | -------------------------------- |
| VT   | 终结符集合（非空）   |                                  |
| VN   | 非终结符集合（非空） | VT ∩ Vn = Ø                      |
| S    | 文法的开始符号       | S ∈ VN                           |
| P    | 产生式集合（有限）   | P → α，P ∈ VN，α ∈ ( VT ∪ VN ) * |

开始符 S 至少必须在某个产生式的左部出现一次

### 2.2 推导

G **文法**，S **开始符号**

- if S *⇨ α，则称 α 是一个[句型]()

- 仅含终结符号的[句型]()是一个句子

- **文法** G 所产生的句子的全体是一个[语言 L(G)]()

---

由**文法**求[语言]()：

> G(A): A → c|Ab

A ⇨ c

A ⇨ Ab ⇨ c b

A ⇨ Ab ⇨ cb b

L(G)={ c,cb,cbb,... }

---

由[语言]()求**文法**：

> L(G)={ a^n * b^n | n >= 1 }

n=1,ab

n=2,a[ab]()b

n=3,aa[ab]()bb

G(s): S → ab|aSb

### 2.3 语法分析树与二义性

一颗语法树是不同推导过程的共性抽象

定义：

- 如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的
- 也就是说，若一个文法中存在某个句子，它有两个不同的最左（最右）推导，则这个文法是二义的

例题：

> 令文法为：
>
> E → T | E+T | E-T
>
> T → F | T*F | T/F
>
> F → (E) | i
>
> 1. 给出 **i + i * i** 、**i * ( i + i )** 的最左推导和最右推导 
>
>    |                   | 最左推导                                                     | 最右推导                                                     |
>    | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
>    | **i + i * i**     | E => [E + T]()<br />E => [T]() + T<br />E => [F]() + T<br />E => [i]() + T<br />E => i + [T * F]()<br />E => i + [F]() * F<br />E => i + [i]() * F<br />E => i + i * [i]() | E => [E + T]()<br />E => E + [T * F]()<br />E => E + T * [i]()<br />E => E + [F]() * i<br />E => E + [i]() * i<br />E => [T]() + i * i<br />E => [F]() + i * i<br />E => [i]() + i * i |
>    | **i * ( i + i )** | E => [T]()<br />E => [T * F]()<br />E => [F]() * F<br />E => [i]() * F<br />E => i * [(E)]()<br />E => i * [(E + T)]()<br />E => i * ([T]() + T)<br />E => i * ([F]() + T)<br />E => i * ([i]() + T)<br />E => i * (i + [F]())<br />E => i * (i + [i]()) | E => [T]()<br />E => [T * F]()<br />E => T * [(E)]()<br />E => T * (E + [T]())<br />E => T * (E + [F]())<br />E => T * (E + [i]())<br />E => T * ([T]() + i)<br />E => T * ([F]() + i)<br />E => T * ([i]() + i)<br />E => [F]() * (i + i)<br />E => [i]() * (i + i) |
>
> 2. 给出 **i + i + i** 、**i + i * i** 、**i - i - i** 的语法树

## 三、词法分析

### 3.1 词法分析器的输出形式

**词法分析：**从左至右逐个字符地对**源程序**进行扫描，产生一个个**单词符号**

**执行词法分析的程序：词法分析器 Lexical Analyzer** 又称**扫描器 Scanner**

> 讨论：词法分析器作为一个独立子程序
>
> 为何要将词法分析作为一个独立阶段呢？是否应该将它安排为独立的一遍呢？
>
> 答：将词法分析安排为一个独立的阶段，可以使整个编译程序结构更简洁，更条理化。词法分析比语法分析简单。它的功能是输入源程序，输出单词符号。并不用将词法分析也作为独立的一遍，即不用

### 3.2 状态转化图

状态转换图是一张**有限方向图**，节点代表**状态**，用圆圈表示

### 3.3正规表达式和有限自动机

#### 3.3.1 正规式与正规集

- **相关概念**

  - 考虑一个有穷**字母表** Σ 字符集，其中每一个元素称为一个**字符**

  - Σ 上的**字**（字符串）是指由 Σ 中的字符所构成的一个有穷序列

  - 不包含任何字符的序列称为**空字**，记为 ε

  - 用 Σ* 表示 Σ 上所有字的全体，包含空字 ε

    > 例如：设 Σ = {a,b}，则
    >
    > Σ* = {ε,a,b,aa,bb,ab,ba,aaa,...} 即 = (a|b)*

  - Σ* 的子集 U 和 V 的[连接积]()定义为

    > UV = {αβ|α∈U & β∈V}

  - V 自身的 [n 次积]()记为

    > V^n = VV...V

  - 规定 V⁰ = {ε}，d令 `V* = V⁰ ∪ V¹ ∪ V² ∪ V³ ∪...` 称 V* 是 V 的闭包

- **正规式和正规集**，对给定的字母表 Σ

  - ε 和 Ø 都是 Σ 上的**正规式**，它们表示的[正规集]()为 {ε} 和 Ø

  - 任何 a ∈ Σ，a 是 Σ 上的**正规式**，他所表示的[正规集]()为 {a}

  - 假定 U 和 V 都是 Σ 上的**正规式**，他们所表示的[正规集]()为 L(U) 和 L(V)

    | 优先级            | 运算名 | 正规式 | 正规集    |
    | ----------------- | ------ | :----- | :-------- |
    | :3rd_place_medal: | 或\|   | (U\|V) | L(U)∪L(V) |
    | :2nd_place_medal: | 连接.  | (U.V)  | L(U)L(V)  |
    | :1st_place_medal: | 闭包*  | (U)*   | (L(U))*   |

  - 例题：

    > Σ = {a,b}
    >
    > | 正规式                   | 正规集                             |
    > | ------------------------ | ---------------------------------- |
    > | ba*                      | ∑ 上所有以 b 为首后跟任意个 a 的字 |
    > | a(a\|b)*                 | ∑ 上所有以 a 为首的字              |
    > | (a\|b)* (aa\|bb) (a\|b)* | ∑ 上所有含有 aa 或 bb 的字         |

- **正规式等价**

  - 正规集相同，则正规式等价

    > 例：b(ab)* <=> (ba)*b
    >
    > | b(ab)*                                                       | (ba)*b                                                       |
    > | ------------------------------------------------------------ | ------------------------------------------------------------ |
    > | L(b(ab)\*)<br/>= L(b) L((ab)\*)<br/>= L(b) (L(ab))\*<br/>= L(b) (L(a) L(b))\*<br/>= {b} {ab}\*<br/>= {b} {ε,ab,abab,ababab,...}<br/>= {ε.bab,babab,bababab,...} | L((ba)\*b)<br/>= L((ba)\*) L(b)<br/>= (L(ba))\* L(b)<br/>= (L(b) L(a))\* L(b)<br/>= {ba}\* {b}<br/>= {ε,ba,baba,bababa,...} {b}<br/>= {ε,bab,babab,bababab,...} |

- **正规式的性质**

  - |        | \|或运算              | .连接运算         |
    | ------ | --------------------- | ----------------- |
    | 交换律 | U\|V = V\|U           |                   |
    | 结合律 | U\|(V\|F) = (U\|V)\|F | U (VF) = (UV) F   |
    | 分配律 | U (V\|F) = UV\|UF     | (V\|F) U = VU\|FU |

  - Uε = εU = U

  - UV <> VU
  
- 测验：

  > 1. 给出下面正规表达式
  >    1. 以 01 结尾的二进制串
  >
  >       > (0|1)* 01
  >
  >    2. 含有 010 的二进制串
  >
  >       > (0|1)* 010 (0|1)*
  >
  >    3. 以 aa 或 bb 开头，以 b 结尾的由 a 和 b 组成的符号串
  >
  >       > (aa|bb) (a|b)* b
  >
  > 2. 写出以下正规式对应的正规集
  >
  >    | 正规式     | 1(0\|1)* 101               | 0\* 1 0\* 1 0\*    | (0\|1)* 10 (0\|1)* |
  >    | ---------- | -------------------------- | ------------------ | ------------------ |
  >    | **正规集** | 以1打头，101结尾的二进制串 | 包含2个1的二进制串 | 包含10的二进制串   |

#### 3.3.2 确定有限自动机（DFA）

- 一个确定有限自动机 M 是一个五元式 M = (S,Σ,δ,s₀,F)

  |      |                      |                                                              |
  | ---- | -------------------- | ------------------------------------------------------------ |
  | S    | 有穷状态集           | DFA 的所有状态                                               |
  | ∑    | 输入字母表（有穷）   | 输入符号集合                                                 |
  | δ    | 状态转换函数         | 为 S×∑→S 的单值部分映射<br/>**δ(s,a)=s'** 当前行为状态为 s，输入字符为 a 时，<br/>状态转换到下一状态 s'，s' 为 s 的一个后继状态 |
  | s₀   | 开始状态（初始）     | unique，s₀∈S                                                 |
  | F    | 接收状态集合（终止） | F⊆S                                                          |

- 确定有限自动机（DFA）的表示

  - 一个 DFA 可以用一个[状态转换矩阵]()表示，矩阵的**行**表示**状态**，**列**表示**输入字符**，**矩阵元素**表示 **δ(s,a) 的值**

  - 一个 DFA　可以表示为[状态转换图]()

    假定 DFA M 含有 **m 个状态**和 **n 个输入字符**，那么，这个图含有 **m 个状态节点**，每个结点最多含有 n 条箭弧射出，且每条箭弧用 Σ 上不同的输入字符来做标记

  例题：

  > DFA M = ({0,1,2,3} , {a,b} , f , 0 , {3})，f 定义如下：
  >
  > f(0,a)=1        f(0,b)=2
  >
  > f(1,a)=3        f(1,b)=2
  >
  > f(2,a)=1        f(2,b)=3
  >
  > f(3,a)=3        f(3,b)=3
  >
  > 1. 状态转换矩阵
  >
  >    |      |  a   |  b   |
  >    | :--: | :--: | :--: |
  >    |  0   |  1   |  2   |
  >    |  1   |  3   |  2   |
  >    |  2   |  1   |  3   |
  >    |  3   |  3   |  3   |

- 确定有限自动机（DFA）

  - 对于 Σ* 中的任何字 α，若存在一条从初态到某一终态的道路，且这条路上所有弧上的**标记符**连接成的**字**等于 α，则称 α 为 DFA M 所[识别]()（接收）
  - DFA M 所识别的**字 α **的**全体**称为该 DFA [识别（接收）的语言]()，记为 L(M)

#### 3.3.3 非确定有限自动机（NFA）

- 一个**非**确定有限自动机 M 是一个五元式 M = (S,Σ,δ,s₀,F)

  |      |                          |                                  |
  | ---- | ------------------------ | -------------------------------- |
  | S    | 有穷状态集               |                                  |
  | ∑    | 输入字母表（有穷）       |                                  |
  | δ    | 状态转换函数             | 为 S×∑*→2^S 的[非]()单值部分映射 |
  | s₀   | 开始状态[集合]()（初始） | s₀[⊆]()S                         |
  | F    | 接收状态集合（终止）     | F⊆S                              |

- 区别

  |                | 确定有限自动机 DFA   | 非确定有限自动机 NFA                   |
  | -------------- | -------------------- | -------------------------------------- |
  | 弧上标志       | 只能时单个字符       | 可以是 Σ* 中的一个字，也可以是空字 ε   |
  |                |                      | 同一个字可能出现在同状态射出的多条弧上 |
| 初态不同       | 唯一的初态           | 非空初态集                             |
  | δ 映射函数不同 | S×Σ→S 的单值部分映射 | S×ΣΣ*→2^S 的[非]()单值部分映射         |
  
  DFA 是 NFA 的特例

#### 3.3.4 NFA 到 DFA 的转换

- 有限自动机的等价
  - 定义：对于任何两个有限自动机 M 和 M'，如果[识别的语言相同]()即 L(M) = L(M')，则称 M 与 M' **等价**
  - 对于每一个 NFAM 存在一个 DFAM'，使得 L(M) = L(M')，即 DFA 与 NFA 描述能力相同

- **替换规则**

  ![3.3.4 替换规则](N:\Desktop\review\CompilerPrinciple\images\3.3.4 替换规则.png)

- **例：**

  > ![3.3.4 替换规则-例-M转换M'](images\3.3.4 替换规则-例-M转换M'.png)

- **用子集法将 M' 变换为 DFA**

  1. 设 I 是 M' 的状态集的一个子集，定义 I 的 ε- 闭包 **ε-closure(I)** 为：

     1. 若 s∈I ，则 s∈**ε-closure(I)**
     2. 若 s∈I ，则从 s 出发经过[任意条]() ε 弧而能到达的任何状态 s' 都属于 **ε-closure(I)**

     即：**ε-closure(I)** = I∪{s'|从某个状态 s∈I 出发经过[任意条]() ε 弧能到达的任何状态 s'}

  2. 设 a 是 Σ 中的一个字符，定义 **I**a = **ε-closure(J)**

     其中，J 为 I 中某个状态出发经过**一条 a 弧**而到达的状态集合

     ![3.3.4](images\3.3.4-确定化过程-0.png)

  3. 确定化的过程：

     设字母表只包含两个 a 和 b，我们构造一张表：

     | I                  | Ia   | Ib   |
     | ------------------ | ---- | ---- |
     | **ε-closure({X}}** |      |      |

     1. 首先，置第 1 行、第 1 列为 ε-closure({X}} 求出这一列的 Ia，Ib；
     2. 然后检查这两个 Ia、Ib，把它们是否已在表中是第一列出现，把未曾出现的填入后面的空行的第 1 列上，求出每行第 2，3列上的集合...
     3. 重复上述过程，直到所有的第 2，3 列子集全部出现在第一列为止。
     4. 把这张表看成一个**状态转换矩阵**，把其中的每个**子集**看成一个**状态**。
     5. 这张表唯一刻画了一个确定的有限自动机 M，它的初态是 **ε-closure({X}}**，它的终态是含有**原终态 Y** 的子集

- **例：**

  > ![3.3.4-例题-答案](images\3.3.4-确定化过程-例题.png)
  >
  > | I           | Ia                                                           | Ib                                                           |
  > | ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  > | X→ε={X,5,1} | J=X→a={5,3}（不包含自身 X）<br/>**I**a=**ε-closure(J)**=J→ ε={5,3,1} | J=X→b={5,4}（不包含自身 X）<br/>**I**b=**ε-closure(J)**=J→ ε={5,4,1} |
  >
  > ![3.3.4-例题-答案](images\3.3.4-确定化过程-例题-答案.png)

#### 3.3.5 确定有限自动机的化简

- **DFA M 的化简（最小化）：**

  寻找一个状态数比 M 少的 DFA M'，使得 L(M)=L(M')

- **等价状态：**

  假设 s 和 t 为 M 的两个状态，如果从状态 s 出发能读出某个字 α 而停止于终态，那么同样，从 t 出发也能读出 α 而停止与终态，则称 s 和 t [等价]()

  两个状态不等价，则称它们是[可区别]()的

- **对一个 DFA M 最小化的基本思想：**

  把 M 的状态集划分为一些不相交的子集，使得任何两个**不同子集**的状态是**可区别**的，而**同一子集**的任何两个状态是**等价**的。最后，让每个子集选出一个代表，同时消去其他状态。

- **最小化的具体做法：**

  对 M 的状态集进行划分

  - 首先，把 S 划分为终态和非终态两个子集，形成基本划分 π。

  - 既定到某个时候，π 已含 m 个子集，记为 π={I¹,I²,...}，检查 π 中的每个子集看能否进一步划分：

    对某个 I<sup>(i)</sup>，令 I<sup>(i)</sup>={s₁,s₂,...} ，若存在一个输入字符 a 使得 Ia<sup>(i)</sup> 不会包含在现行 π 的某个子集 I<sup>(i)</sup> 中，则至少应把 I<sup>(i)</sup> 分为两个部分

- 例

  > ![3.3.5-例题-1](images\3.3.5-例题-1.png)
  >
  > ![3.3.5-例题-2](images\3.3.5-例题-2.png)

## 四、语法分析-自上而下

### 4.1 文法的左递归

| 直接左递归          | 间接左递归     |
| ------------------- | -------------- |
| 文法存在产生式 P→Pα | 存在推导 P+⇒Pα |

### 4.2 LL(1) 分析法

#### 4.2.1 左递归的消除

- [直接]()左递归的**消除条件**

  若有 `P→Pα|β` （其中 α 非 ε 且 β 不以 P 打头）

  则有 P+⇒βα<sup>n</sup>

- 公式：

  - 由：

    `P→Pα|β` 

  - 得：

    `P→βP'`

    `p'→αP'|ε`

- 例子：**表达式文法直接左递归的消除**

  > E → E+T|T
  >
  > 过程：
  >
  > ​	α=+T
  >
  > ​	β=T
  >
  > 答案：
  >
  > ​	E→TE'
  >
  > ​	E'→+TE'|ε

- [间接]()左递归的**消除条件**

#### 4.2.2 First 集的定义

- 例题：

  > ① S→**a**A
  >
  > ② S→**d**
  >
  > ③ A→**b**AS
  >
  > ④ A→**ε**
  >
  > > FIRST(S)={a,d}
  > >
  > > FIRST(A)={b,ε}

- 例题：

  > ① A→**b**aS
  >
  > ② A→**ε**
  >
  > ③ S→Aa
  >
  > ④ S→**d**
  >
  > > FIRST(A)={b,ε}
  > >
  > > ③ S→Aa 经过 ① 得：S→**b**aSa
  > >
  > > ​				经过 ② 得：S→εa=**a**
  > >
  > > FIRST(S)={b,a,d}

#### 4.2.3 消除回溯

- **方法：**[提取公共左因子]()

- 例题：

  > B→bBcA|b
  >
  > > 1. 提取左因子 b
  > >
  > >    B→b(BcA|ε)
  > >
  > > 2. 改写产生式
  > >
  > >    B→bB'
  > >
  > >    B'→BcA|ε

### 4.3 预测分析程序

#### 4.3.1 Follow 集的定义

- 定义：

  FOLLOW(A)={**a**|S→...A[a]()...}

  FOLLOW(A)={**#**|S→...A}

- 也就是说，FOLLOW(A) 是所有句型中，紧跟在 A 后的**终结符**或 **#**

- 例子：

    > ① S→aA
    >
    > ② A→ε
    >
    > ③ S→d
    >
    > ④ A→bAS
    >
    > > - 根据 ① S→aA 得：FOLLOW(A)={#}
    > >
    > >   - ⇒④⇒ S→abAS
    > >     - ⇒①⇒ S→abA[a]()A 得：FOLLOW(A)={a}
    > >     - ⇒③⇒ S→abA[d]() 得：FOLLOW(A)={d}
    > >
    > >   ∴ FOLLOW(A)={#,a,d}
    > >
    > > - 根据 ① S→aA
    > >
    > >   - ⇒④⇒ S→abAS 得：FOLLOW(S)={#}
    > >     - ⇒④⇒ S→abbASS 
    > >       - ⇒①⇒ S→abbAS[a]()A 得：FOLLOW(S)={a}
    > >       - ⇒③⇒ S→abbAS[d]() 得：FOLLOW(S)={d}
    > >
    > >   ∴ FOLLOW(S)={#,a,d}

- 作业：

    > 设文法 G(S):
    >
    > S→(L)|aS|a
    >
    > L→LbS|S
    >
    > 1. 消除左递归和回溯
    >
    >    > - 消除回溯
    >    >
    >    >   S→(L)|aS'
    >    >
    >    >   S'→S|ε
    >    >
    >    > - 消除左递归
    >    >
    >    >   L→SL'
    >    >
    >    >   L'→bSL'|ε
    >
    > 2. 在 1. 的基础上，计算每个非终结符号的 FIRST 集和 FOLLOW 集
    >
    >    ① S→(L)|aS'
    >
    >    ② S'→S|ε
    >
    >    ③ L→SL'
    >
    >    ④ L'→bSL'|ε
    >
    >    - FIRST(S)={(,a}
    >
    >      由 ① 得：S→([L]())|**a**S'→**(**SL')|aS'
    >
    >    - FIRST(S')={(,a,ε}
    >
    >      由 ② 得：S'→S|**ε**→FIRST(S)|ε
    >
    >    - FIRST(L)={(,a}
    >
    >      由 ③ 得：L→[S]()L'→FIRST(S)
    >
    >    - FIRST(L')={b,ε}
    >
    >      由 ④ 得：L'→**b**SL'|**ε**
    >
    >    - FOLLOW(S)={#,b,)}
    >
    >      S⇒aS'⇒aS
    >
    >      S⇒(L)⇒(SL')⇒(S**b**SL')⇒(SbSε)⇒(SbS**)**
    >
    >      ​			        ⇒(Sε)⇒(S**)**
    >
    >    - FOLLOW(S')={#,b,)}
    >
    >      S⇒aS'
    >
    >      S⇒(L)⇒(SL')⇒(aS'L')⇒(aS'**b**L')⇒
    >
    >      ​								 ⇒(aS'ε)⇒(aS'**)**
    >
    >    - FOLLOW(L)={)}
    >
    >      S⇒(L**)**
    >
    >    - FOLLOW(L')={)}
    >
    >      S⇒(L)⇒(SL'**)**

#### 4.3.2 LL(1) 文法

#### 4.3.5 FOLLOW 集的构造算法

- 设文法 G[S]，对 G 的所有非终结符，重复作以下计算：

  1. 将 # 加入到 FOLLOW(S)，# 为句子的结束符

  2. 若 A→αBβ，B∈V<sub>N</sub>

     则 FOLLOW(B)=FOLLOW(B)∪**FIRST(β)-{ε}**

  3. 如果 A→αB 或者 A→αBβ，且 β*⇒ε，A≠B

     则 FOLLOW(B)=FOLLOW(B)∪**FOLLOW(A)**

- 表达式文法符号的 FOLLOW 集

    > E→TE'
    >
    > E'→+TE'|ε
    >
    > T→FT'
    >
    > T'→*FT'|ε
    >
    > F→(E)|i
    >
    > 1. FOLLOW(E)={#,)}
    >
    >    1. 针对文法的开始符号 E，根据规则 1，首先包含 #
    >    2. E 出现在哪些产生式的右部？第五条产生式右侧。F→(E)|i 套用规则 2，得 FOLLOW(E)={)}
    >
    > 2. FOLLOW(E')={#,)}
    >
    >    1. E' 出现在哪些产生式的右部？第一条、第二条。
    >
    >       E→TE' 根据规则 3，得 FOLLOW(E')⊇FOLLOW(E)={#,)}
    >
    >       E'→+TE' 根据规则 3，得 FOLLOW(E')⊇FOLLOW(E')={#,)}
    >
    > 3. FOLLOW(T)={+,#,)}
    >
    >    1. T 出现在哪些产生式的右部？第一条、第二条。
    >
    >       E→TE' 根据规则 2，得 FOLLOW(T)=FOLLOW(T)∪FIRST(E')-{ε}={+}
    >
    >       ​			 根据规则 3，得 FOLLOW(T)=FOLLOW(T)∪FOLLOW(E)={#,)}
    >
    > 4. FOLLOW(T')={+,#,)}
    >
    >    1. T' 出现在哪些产生式的右部？第三条、第四条。
    >
    >       T→FT' 根据规则 3，FOLLOW(T')=FOLLOW(T')∪FOLLOW(T)={+,#,)}
    >
    >       T'→*FT' 根据规则 3，FOLLOW(T')=FOLLOW(T')∪FOLLOW(T')
    >
    > 5. FOLLOW(F)={*,+,#,)}
    >
    >    1. F 出现在哪些产生式的右部？第三条、第四条。
    >
    >       T→FT' 根据规则 2，FOLLOW(F)=FOLLOW(F)∪FIRST(T')-{ε}={*}
    >
    >       ​			根据规则 3，FOLLOW(F)=FOLLOW(F)∪FOLLOW(T)={+,#,)}
    >
    >       T'→*FT' 对增大没起作用

#### 4.3.6 预测分析表及其构造

- 预测分析表 M 是一个 M[A,a] 形式的矩阵

  其中，A 为给定文法的非终结符，a 是终结符或 #

- 步骤

  1. 对文法 G 的**每个产生式 A→α**，首先计算 **FIRST(α)**

     如果 FIRST(α) 含有 ε，计算 FOLLOW(A)

  2. 对于每个终结符 **a∈FIRST(α)，把 A→α 加到 M[A,a] 中**
  3. 若 **ε∈FIRST(α)**，则对任何的 **b∈FOLLOW(A)，把 A→α 加到 M[A,a] 中**
  4. 把所有无定义的 M[A,a] 标上“出错标志”

- 预测分析表构造

  > E→TE'
  >
  > E'→+TE'|ε
  >
  > T→FT'
  >
  > T'→*FT'|ε
  >
  > F→(E)|i
  >
  > 1. 对 **E→TE'**
  >
  >    FIRST(TE')=FIRST(T)=FIRST(F)={(,i}
  >
  >    ​	则 M[E,i] = M[E,(] = E→TE'
  >
  >    |       |   i   |  +   |  *   |   (   |  )   |  #   |
  >    | :---: | :---: | :--: | :--: | :---: | :--: | :--: |
  >    | **E** | E→TE' |      |      | E→TE' |      |      |
  >
  > 2. 对 **E'→+TE'|ε**
  >
  >    FIRST(+TE')={+}
  >
  >    ​	则 M[E',+] = **E'→+TE'**
  >
  >    FIRST(ε)=>FOLLOW(E')={#,)}
  >
  >    ​	则 M[E',#] = M[E',)] = **E'→ε**
  >
  >    |        |  i   |    +    |  *   |  (   |  )   |  #   |
  >    | :----: | :--: | :-----: | :--: | :--: | :--: | :--: |
  >    | **E'** |      | E'→+TE' |      |      | E'→ε | E'→ε |
  >
  > 3. 对 **T→FT'**
  >
  >    FIRST(FT')={(,i)}
  >
  >    |       |   i   |  +   |  *   |   (   |  )   |  #   |
  >    | :---: | :---: | :--: | :--: | :---: | :--: | :--: |
  >    | **T** | T→FT' |      |      | T→FT' |      |      |
  >
  > 4. 对 **T'→*FT'|ε**
  >
  >    FIRST(\*FT')={\*}
  >
  >    FIRST(ε)=>FOLLOW(T')={+,#,)}
  >
  >    |        |  i   |  +   |    *    |  (   |  )   |  #   |
  >    | :----: | :--: | :--: | :-----: | :--: | :--: | :--: |
  >    | **T'** |      | T'→ε | T'→*FT' |      | T'→ε | T'→ε |
  >
  > 5. 对 **F→(E)|i**
  >
  >    FIRST((E))={(}
  >
  >    FIRST(i)={i}
  >
  >    |       |  i   |  +   |  *   |   (   |  )   |  #   |
  >    | :---: | :--: | :--: | :--: | :---: | :--: | :--: |
  >    | **F** | F→i  |      |      | F→(E) |      |      |
  >
  > |        |   i   |    +    |    *    |   (   |  )   |  #   |
  > | :----: | :---: | :-----: | :-----: | :---: | :--: | :--: |
  > | **E**  | E→TE' |         |         | E→TE' |      |      |
  > | **E'** |       | E'→+TE' |         |       | E'→ε | E'→ε |
  > | **T**  | T→FT' |         |         | T→FT' |      |      |
  > | **T'** |       |  T'→ε   | T'→*FT' |       | T'→ε | T'→ε |
  > | **F**  |  F→i  |         |         | F→(E) |      |      |

### 第四章综合练习题

> 对以下文法 G
>
> E→TE'
>
> E'→+E|ε
>
> T→FT'
>
> T'→T|ε
>
> F→PF'
>
> F'→*F'|ε
>
> P→(E)|a|b|∧
>
> 1. 计算这个文法的每个非终结符号的 **FIRST 集**和 **FOLLOW 集**
>
>    - FIRST 集
>
>      由 E→[TE']()→[FT']()E'→[PF']()T'E'
>
>      - FIRST(E)=**FIRST(P)**={(,a,b,∧}
>      - FIRST(E')={+,ε}
>      - FIRST(T)=**FIRST(P)**={(,a,b,∧}
>      - FIRST(T')=FIRST(T)∪{ε}={(,a,b,∧,ε}
>      - FIRST(F)=**FIRST(P)**={(,a,b,∧}
>      - FIRST(F')={*,ε}
>      - FIRST(P)={(,a,b,∧}
>
>    - FOLLOW 集
>
>      - FOLLOW(E)={#,)}
>
>        - 针对文法的开始符号 E，根据规则 1，首先包含 #
>        - E'→+E 根据规则 3，FOLLOW(E)=FOLLOW(E)∪FOLLOW(E')= 对扩大 FOLLOW 集没有帮助
>
>        - P→(E) 根据规则 2，FOLLOW(E)=FOLLOW(E)∪FIRST())={)}
>
>      - FOLLOW(E')={#,)}
>
>        - E→TE' 根据规则 3，FOLLOW(E')=FOLLOW(E')∪FOLLOW(E)={#,)}
>
>      - FOLLOW(T)={+,),#}
>
>        - E→TE' 根据规则 2，FOLLOW(T)=FOLLOW(T)∪**FIRST(E')-{ε}**={+,ε}-{ε}={+}
>        - 由于 FIRST(E')⊇{ε}，根据规则 3，FOLLOW(T)=FOLLOW(T)∪FOLLOW(E)={#,)}
>        - T'→T 根据规则 3，FOLLOW(T)=FOLLOW(T)∪FOLLOW(T')= 对扩大 FOLLOW 集没有帮助
>
>      - FOLLOW(T')={+,),#}
>
>        - T→FT' 根据规则 3，FOLLOW(T')=FOLLOW(T')∪FOLLOW(T)={+,),#}
>
>      - FOLLOW(F)={(,a,b,∧,+,),#}
>
>        - T→FT' 根据规则 2，FOLLOW(F)=FOLLOW(F)∪**FIRST(T')-{ε}**={(,a,b,∧,ε}-{ε}={(,a,b,∧}
>        - 由于 FIRST(T')⊇{ε}，根据规则 3，FOLLOW(F)=FOLLOW(F)∪FOLLOW(T)={+,),#}
>
>      - FOLLOW(F')={(,a,b,∧,+,),#}
>
>        - F→PF' 根据规则 3，FOLLOW(F')=FOLLOW(F')∪FOLLOW(F)={(,a,b,∧,+,),#}
>
>      - FOLLOW(P)={}
>
>        - F→PF' 根据规则 2，FOLLOW(P)=FOLLOW(P)∪**FIRST(F')-{ε}**={\*,ε}-{ε}={\*}
>        - 由于 FIRST(F')⊇{ε}，根据规则 3，FOLLOW(P)=FOLLOW(P)∪FOLLOW(F)={\*,(,a,b,∧,+,),#}
>
> 2. 证明这个文法是 LL(1) 文法
>
>    1. 文法不存在左递归
>
>    2. 找含有两个候选式的 FIRST 集不相交
>
>       > E'→+E|ε
>       >
>       > T'→T|ε
>       >
>       > F'→*F'|ε
>       >
>       > P→(E)|a|b|∧
>
>       FIRST(**+E**) ∩ FIRST(**ε**) = ∅
>
>       FIRST(**T**) ∩ FIRST(**ε**) = ∅
>
>       FIRST(**\*F'**) ∩ FIRST(**ε**) = ∅
>
>       FIRST(**(E)**) ∩ FIRST(**a**) ∩ FIRST(**b**) ∩ FIRST(∧) = ∅
>
>    3. 找含有两个候选式，且一个候选式是 ε 的 FIRST 集和  FOLLOW 集不相交
>
>       > E'→+E|ε
>       >
>       > T'→T|ε
>       >
>       > F'→*F'|ε
>
>       FIRST(**E'**) ∩ FOLLOW(**E'**) = ∅
>
>       FIRST(**T'**) ∩ FOLLOW(**T'**) = ∅
>
>       FIRST(**F'**) ∩ FOLLOW(**F'**) = ∅
>
>    故，该文法是 LL(1) 文法。
>
> 3. 构造它的预测分析表
>
>    1. 对 E→TE'
>
>       FIRST(TE')=FIRST(T)={(,a,b,∧}
>
>    2. 对 E'→+E|ε
>
>       FIRST(+E)={+}
>
>       FIRST(ε)=>FOLLOW(E')={#,)}
>
>    3. 对 T→FT'
>
>       FIRST(FT')=FIRST(F)={(,a,b,∧}
>
>    4. 对 T'→T|ε
>
>       FIRST(T)={(,a,b,∧}
>
>       FIRST(ε)=>FOLLOW(T')={+,),#}
>
>    5. 对 F→PF'
>
>       FIRST(PF')=FIRST(P)={(,a,b,∧}
>
>    6. 对 F'→*F'|ε
>
>       FIRST(\*F')={\*}
>
>       FIRST(ε)=>FOLLOW(F')={(,a,b,∧,+,),#}
>
>    7. 对 P→(E)|a|b|∧
>
>       FIRST((E))={(}
>
>       FIRST(a)={a}
>
>       FIRST(b)={b}
>
>       FIRST(∧)={∧} 
>
>    |      |   +   |   *    |   (   |  )   |   a   |   b   |   ∧   |  #   |
>    | :--: | :---: | :----: | :---: | :--: | :---: | :---: | :---: | :--: |
>    |  E   |       |        | E→TE' |      | E→TE' | E→TE' | E→TE' |      |
>    |  E'  | E'→+E |        |       | E'→ε |       |       |       | E'→ε |
>    |  T   |       |        | T→FT' |      | T→FT' | T→FT' | T→FT' |      |
>    |  T'  | T'→ε  |        | T'→T  | T'→ε | T'→T  | T'→T  | T'→T  | T'→ε |
>    |  F   |       |        | F→PF' |      | F→PF' | F→PF' | F→PF' |      |
>    |  F'  | F'→ε  | F'→*F' | F'→ε  | F'→ε | F'→ε  | F'→ε  | F'→ε  | F'→ε |
>    |  P   |       |        | P→(E) |      |  P→a  |  P→b  |  P→∧  |      |

## 五、语法分析-自下而上

### 5.1 自下而上分析基本问题

#### 5.1.1 移进-规约法

#### 5.1.2 句柄与规范规约

- 一个句型的最左直接短语称为该句型的**句柄**

### 5.2 LR 分析法

#### 5.2.1 LR 分析过程

#### 5.2.2 LR 分析过程示例

#### 5.2.3 活前缀与可规约前缀

- 例：

  | 文法 G[S]                        | 为产生式加序号                                               | 对 abbcde 最右推导                                           | 对它的逆过程最左规约                                         |
  | -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | S→aAcBe<br/>A→b<br/>A→Ab<br/>B→d | S→aAcBe**[1]**<br/>A→b**[2]**<br/>A→Ab**[3]**<br/>B→d**[4]** | S⇒aAc[B]()e**[1]**<br>  ⇒a[A]()cd**[4]**e**[1]**<br>  ⇒a[A]()b**[3]**cd**[4]**e**[1]**<br>  ⇒ab**[2]**b**[3]**cd**[4]**e**[1]** | <= ab**[2]**b**[3]**cd**[4]**e**[1]**<br><= a[A]()b**[3]**cd**[4]**e**[1]**<br/><= a[A]()cd**[4]**e**[1]**<br/><= aAc[B]()e**[1]**<br/><= S |

  哪个产生式继续规约[仅取决于]()当前句型的前部。我们把每次采取规约动作前的符号串部分称为**可规前缀**。

  | abbcde 的规范规约为                   | 活前缀          | 活前缀（可规前缀） |
  | ------------------------------------- | --------------- | ------------------ |
  | <= ab**[2]**b**[3]**cd**[4]**e**[1]** | ε,a             | ab                 |
  | <= a[A]()b**[3]**cd**[4]**e**[1]**    | ε,a,aA          | aAb                |
  | <= a[A]()cd**[4]**e**[1]**            | ε,a,aA,aAc      | aAcd               |
  | <= aAc[B]()e**[1]**                   | ε,a,aA,aAc,aAcB | aAcBe              |
  | <= S                                  |                 |                    |

  - 可规前缀：**[]** 以前的部分
  - 活前缀：**[]** 以前部分的前缀 包括可规前缀

#### 5.2.4 项目及其分类

- 对文法 G 的每个产生式的右部添加一个圆点就构成一个项目

  | 产生式 | 项目                                    |
  | ------ | --------------------------------------- |
  | A→XYZ  | A→·XYZ<br/>A→X·YZ<br/>A→XY·Z<br/>A→XYZ· |
  | A→ε    | A→·                                     |

- 项目的直观意义：

  指明在分析过程中的某一时刻**已经归约**的部分和**等待归约**部分

- 项目分类

  | 项目类型 | 简介                     | 举例                                                         |
  | -------- | ------------------------ | ------------------------------------------------------------ |
  | 移进     | 后继符号为终结符的项目   | A→α·aβ，a∈V<sub>T</sub>，此时把 a 移进，即 a 进符号栈        |
  | 待约     | 后继符号为非终结符的项目 | A→α·Xβ，X∈V<sub>N</sub>，称为待约项目。<br/>此时期待着从余留的输入符号中进行归约而得到 X |
  | 归约     | 后继符号为空的项目       | A→α·，此时已把 α 分析结束，α 已在栈顶，<br>从而可按相应的产生式进行归约 |
  | 接受     |                          | 当归约项目为 S'→S· 时，则表明已分析成功，<br>即输入串为该文法的句子，相应的状态为接受状态 |

#### 5.2.5 项目集闭包及 GO 函数

- 例：文法 G[S]

  > S→A
  >
  > A→aAb
  >
  > A→c

  设开始状态为 S<sub>0</sub>，且 S<sub>0</sub>={S→·A}，则

  CLOSURE(S<sub>0</sub>)={S→·A,A→·aAb,A→·c}

- GO 函数的定义：

  > GO(I,X)=closure(J)
  >
  > A→α·Xβ∈I
  >
  > J={任何形如 A→αX·β 的项目}

- GO(I,X) 函数的直观意义：

  它规定了识别文法规范句型活前缀的 DFA 从状态 I （项目集）出发，经过 X 弧所应该到达的**状态**（项目集合）

- 例：文法 G[S]

  > S →aA
  >
  > A→aAb
  >
  > A→d
  >
  > 令 I<sub>0</sub>={S→·aA}，则

  GO(I<sub>0</sub>,a)=closure{S→a·A}={S→a·A,·aAb,·d}

#### 5.2.6 LR(0) 项目集规范族的构造

#### 5.2.7 LR(0) 项目集规范族的构造示例

- 例：文法 G(E) 为：

  > E→aA|bB
  >
  > A→cA|d
  >
  > B→cB|d
  >
  >  求此文法的 LR(0) 项目集规范族（或识别其活前缀的 DFA）

  1. 对文法进行拓广：

     | (0) S'→E | (1) E→aA | (2) E→bB | (3) A→cA | (4) A→d | (5) B→cB | (6) B→d |
     | -------- | -------- | -------- | -------- | ------- | -------- | ------- |
     |          |          |          |          |         |          |         |

  2. 给出拓广文法的所有项目：

     | (1) S'→·E | (3) E→·aA | (6) E→·bB | (9) A→·cA  | (12) A→·d | (14) B→·cB | (17) B→·d |
     | --------- | --------- | --------- | ---------- | --------- | ---------- | --------- |
     | (2) S'→E· | (4) E→a·A | (7) E→b·B | (10) A→c·A | (13) A→d· | (15) B→c·B | (18) B→d· |
     |           | (5) E→aA· | (8) E→bB· | (11) A→cA· |           | (16) B→cB· |           |

  3. 项目集族

     1. 

        > I<sub>0</sub>=closure({S'→·E})={S'→·[E](),E→·[a]()A,E→ ·[b]()B}

     2. 检查 I<sub>0</sub> 的哪些 GO 函数不为空

        > I<sub>1</sub>=GO(I<sub>0</sub>,[E]())={S'→E·}
        >
        > I<sub>2</sub>=GO(I<sub>0</sub>,[a]())={E→a·A,A→·cA,A→·d}
        >
        > I<sub>3</sub>=GO(I<sub>0</sub>,b)={E→b·B,B→·cB,B→·d}

     3. 检查 I<sub>1</sub> I<sub>2</sub> I<sub>3</sub> 的哪些 GO 函数不为空

        1. I<sub>2</sub> 不为空

           > I<sub>4</sub>=GO(I<sub>2</sub>,A)={E→aA·}
           >
           > I<sub>5</sub>=GO(I<sub>2</sub>,c)={A→c·A,A→·cA,A→·d}
           >
           > I<sub>6</sub>=GO(I<sub>2</sub>,d)={A→d·}

        2. I<sub>3</sub> 不为空

           > I<sub>7</sub>=GO(I<sub>3</sub>,B)={E→bB·}
           >
           > I<sub>8</sub>=GO(I<sub>3</sub>,c)={B→c·B,B→·cB,B→·d}
           >
           > I<sub>9</sub>=GO(I<sub>3</sub>,d)={B→d·}

     4. 检查 I<sub>4</sub> I<sub>5</sub> I<sub>6</sub> I<sub>7</sub> I<sub>8</sub> I<sub>9</sub>的哪些 GO 函数不为空

        1. I<sub>5</sub> 不为空

           > I<sub>10</sub>=GO(I<sub>5</sub>,A)={A→cA·}
           >
           > I<sub>5</sub>=GO(I<sub>5</sub>,c)={A→c·A,A→·cA,A→·d}
           >
           > I<sub>6</sub>=GO(I<sub>5</sub>,d)={A→d·}

         2. I<sub>8</sub> 不为空

            > I<sub>11</sub>=GO(I<sub>8</sub>,B)={B→cB·}
            >
            > I<sub>8</sub>=GO(I<sub>8</sub>,)={B→c·B,B→·cB,B→·d}
            >
            > I<sub>9</sub>=GO(I<sub>8</sub>,)={B→d·}

#### 5.2.8 LR(0) 分析表的构造

- LR(0) 文法定义：

  假若一个文法 G 的拓广文法 G' 的活前缀识别自动机中的每个状态（项目集）中不存在以下情况

  - 既含移进项目又含归约项目
  - 或者含有多个归约项目

  则称 G 是一个 LR(0) 文法

- 设有文法 G[S]，则 LR(0) 分析表的构造规则为：
  1. 对于 A→α·aβ∈I<sub>i</sub>，a∈V<sub>t</sub> 且 GO(I<sub>i</sub>,a)=I<sub>j</sub>，则置 action[i,a]=S<sub>j</sub>
  2. 对于 A→α·Xβ∈I<sub>i</sub>，X∈V<sub>N</sub> 且 GO(I<sub>i</sub>,X)=I<sub>j</sub>，则置 GOTO[i,X]=j
  3. 对于 A→α·∈I<sub>i</sub>，若 A→α 是文法的第 j 个产生式，则对所有的 x∈V<sub>t</sub>，均置 action[i,x]=r<sub>j</sub>
  4. 若 S→α·∈I<sub>i</sub>，则置 action[I<sub>i</sub>,#]=acc

- 例

  > I<sub>0</sub>={S'→·E,E→·aA,E→·bB}
  >
  > GO(I<sub>0</sub>,E)=I<sub>1</sub>
  >
  > GO(I<sub>0</sub>,a)=I<sub>2</sub>
  >
  > GO(I<sub>0</sub>,b)=I<sub>3</sub>

  | 状态 | ACTION | ACTION | ACTION | ACTION | ACTION | GOTO | GOTO | GOTO |
  | ---- | ------ | ------ | ------ | ------ | ------ | ---- | ---- | ---- |
  |      | a      | b      | c      | d      | #      | E    | A    | B    |
  | 0    | s2     | s3     |        |        |        | 1    |      |      |

  I<sub>1</sub>={S'→E·}，I<sub>6</sub>={E→aA·}

  | 状态 | ACTION | ACTION | ACTION | ACTION | ACTION | GOTO | GOTO | GOTO |
  | ---- | ------ | ------ | ------ | ------ | ------ | ---- | ---- | ---- |
  |      | a      | b      | c      | d      | #      | E    | A    | B    |
  | 0    | s2     | s3     |        |        |        | 1    |      |      |
  | 1    |        |        |        |        | acc    |      |      |      |
  | 6    | r1     | r1     | r1     | r1     | r1     |      |      |      |

- 作业

  > 对文法 G[S]
  >
  > S→aS|b

  1. 列出这个文法的所有 LR(0) 项目

     1. 首先将文法 G[S] 拓广为 G[S']

        | (0) S'→S | (1) S→aS | (2) S→b |
        | -------- | -------- | ------- |
        |          |          |         |

     2. 这个文法的项目有

        | S'→·S | S→·aS | S→·b |
        | ----- | ----- | ---- |
        | S'→S· | S→a·S | S→b· |
        |       | S→aS· |      |

  2. 构造这个文法的 LR(0) 项目集规范族

     1. 

        I<sub>0</sub>=closure({S'→·S})={S'→·[S](),S→·[a]()S,S→·[b]()}

     2. 检查 I<sub>0</sub> 的哪些 GO 函数不为空

        I<sub>1</sub>=GO(I<sub>0</sub>,[S]())=closure({S'→S·})={S'→S·}

        I<sub>2</sub>=GO(I<sub>0</sub>,[a]())=closure({S→a·S})={S→a·S,S→·aS,S→·b}

        I<sub>3</sub>=GO(I<sub>0</sub>,[b]())=closure({S→b·})={S→b·}

     3. 检查 I<sub>1</sub> I<sub>2</sub> I<sub>3</sub> 中哪些 GO 函数不为空，I<sub>2</sub> 不为空

        I<sub>4</sub>=GO(I<sub>2</sub>,S)=closure({S→aS·})={S→aS·}

        I<sub>2</sub>=GO(I<sub>2</sub>,a)=closure({S→a·S})={S→a·S,S→·aS,S→·b}

        I<sub>3</sub>=GO(I<sub>2</sub>,b)=closure({S→b·})={S→b·}

  3. 识别活前缀的 DFA

     ![5.2.8-LR(0)分析表的构造-作业-答案3](N:\Desktop\review\CompilerPrinciple\images\5.2.8-LR(0)分析表的构造-作业-答案3.png)

#### 5.2.9 SLR(1) 冲突解决方案

## 六、属性文法与语法制导翻译

### 6.1 属性文法

- **属性文法**，也称**属性翻译文法** or **语法制导定义**

- 语义规则：属性的计算规则

- 属性文法的形式：

  | 产生式 | 语义规则                                           |
  | ------ | -------------------------------------------------- |
  | A→α    | b:=(c<sub>1</sub>,c<sub>2</sub>,...,c<sub>k</sub>) |

  f 是一个函数，表示属性 b **依赖**于属性 c<sub>1</sub>,c<sub>2</sub>,...,c<sub>k</sub>

- 如果在 A→α b:=(c<sub>1</sub>,c<sub>2</sub>,...,c<sub>k</sub>) 中

  - b 是 A 的一个属性并且 c<sub>1</sub>,c<sub>2</sub>,...,c<sub>k</sub> 是产生式右部文法符号的属性时，称 A 为综合属性
  - b 是产生式右边某个文法符号的一个属性并且 c<sub>1</sub>,c<sub>2</sub>,...,c<sub>k</sub> 是 A or 产生式右部任何文法符号的属性，称 b 为继承属性

- 例1

  E→E<sub>1</sub>+T	E.val:=E<sub>1</sub>.val+T.val

- 例2

  D→TL		L.in:=T.type 

  L→L<sub>1</sub>,id	L<sub>1</sub>.in:=L.in

- 终结符只有综合属性
- 非终结符既有综合属性也有继承属性

### 6.2 综合属性值的计算

- 综合属性：在语法树中，一个结点的综合属性的值由其子节点的属性值确定

  综合属性用于“自下而上”传递信息

### 6.3 继承属性值的计算

- 继承属性：在语法树中，一个结点的继承属性由此结点的父节点和（或）兄弟点的某些属性确定

### 6.4 L-属性文法及其翻译模式

### 6.5 根据属性文法构造翻译模式

## 七、语义分析和中间代码产生

### 7.1 后缀式

- 作业 逆波兰表示

  1. ```SPARQL
     -a-(b*c/(c-d)+(-b)*a)
     (-a)'(b*c/(c-d)+(-b)*a)'-
     a⊖([b*c/(c-d)]'[(-b)*a]'+)-
     a⊖([(b*c)'(c-d)'/][(-b)'a*]+)-
     a⊖([bc*cd-/][b⊖a*]+)-
     a⊖(bc*cd-/b⊖a*+)-
     a⊖bc*cd-/b⊖a*+-
     ```

  2. ```SPARQL
     -A+B*C/D
(-A)'(B*C/D)'+
     A⊖BC*D/+
     ```
     
  3. ```SPARQL
     x:=a-b/(c+d)
     x:=a(b/[c+d])'-
     x:=a(b[c+d]'/)-
     x:=a(bcd+/)-
     x:=abcd+/-
     xabcd+/-:=
     ```
  

### 7.2 三地址代码

### 7.3 三地址代码的具体表示形式

- 作业

  > 写出表达式：`A+B*(C-D)-E/F` 的逆波兰表示、三元式表示和四元式表示

  1. 逆波兰表示

     ```SPARQL
     A+B*(C-D)-E/F
     (A[B*(C-D)]'+)-(EF/)
     (A[B(C-D)'*]+)(EF/)-
     (A[B(CD-)*]+)(EF/)-
     ABCD-*+EF/-
     ```

  2. 三地址代码形式：

     ```
     T1=C-D
     T2=B*T1
     T3=A+T2
     T4=E/F
     T5=T3-T4
     ```

  3. 三元式表示

     |      | op   | arg1 | arg2 |
     | ---- | ---- | ---- | ---- |
     | (0)  | -    | C    | D    |
     | (1)  | *    | B    | (0)  |
     | (2)  | +    | A    | (1)  |
     | (3)  | /    | E    | F    |
     | (4)  | -    | (2)  | (3)  |

  4. 四元式表示

     |      | op   | arg1 | arg2 | result |
     | ---- | ---- | ---- | ---- | ------ |
     | (0)  | -    | C    | D    | T1     |
     | (1)  | *    | B    | T1   | T2     |
     | (2)  | +    | A    | T2   | T3     |
     | (3)  | /    | E    | F    | T4     |
     | (4)  | -    | T3   | T4   | T5     |

## 十、优化

### 10.1 代码优化概念

### 10.2 常用的代码优化方法

1. 删除公共子表达式
2. 代码外提
3. 强度削弱
4. 删除归纳变量
5. 合并已知量
6. 删除无用赋值

### 10.3 基本块

- **入口语句的确认方法**
  1. 程序的第一个语句
  2. 由**转移语句**转移到的语句
  3. 紧跟在**条件转移语句**后面的语句
- **出口语句的确认方法**
  1. 转移语句
  2. 停语句

### 10.4 基本块的优化 

## 十一、目标代码生成

### 11.1 目标代码生成概述

### 11.2 目标代码生成算法

### 11.3 目标代码生成示例

- 作业

  > 假设可用寄存器为 R0 和 R1，T4 是基本块出口之后的活跃变量。将下面基本块的中间代码序列生成目标代码。
  >
  > T1:=A+B
  >
  > T2:=C+D
  >
  > T3:=E-T2
  >
  > T4:=T1-T3

  | 目标代码  | R0   | R1   |
  | --------- | ---- | ---- |
  | LD R0 A   | A    |      |
  | ADD R0 B  | T1   |      |
  | LD R1 C   |      | C    |
  | ADD R1 D  |      | T2   |
  | ST R0 T1  |      |      |
  | LD R0 E   | E    |      |
  | SUB R0 R1 | T3   |      |
  | LD R1 T1  |      | T1   |
  | SUB R1 R0 | T4   |      |
  | ST R1 T4  |      |      |

  