1. 编程求以孩子兄弟表示法存储的森林的叶子结点数

   > 解答：
   >
   > 当森林（树）以孩子兄弟表示法存储时，若结点没有孩子（fch=null），则它必是叶子，总的叶子结点个数是孩子子树（fch）上的叶子数和兄弟子树(nsib)上的叶结点个数之和。
   >
   > 算法代码如下：
   >
   > ```
   > typedef struct node
   > {
   >      ElemType data;     //数据域
   >      struct node *fch,*nsib;    //孩子与兄弟域
   > }*Tree
   > int Leaves(Tree t){    //计算以孩子兄弟表示法存储的森林的叶子数
   >     if(t==NULL)
   >           return 0;     //树空返回0
   >     if(t->fch==NULL)      //若结点无孩子，则该结点必是叶子
   >           return 1+Leaves(t->nsib);   //返回叶子结点和其兄弟子树中的叶子结点数
   >     else        //孩子子树和兄弟子树中叶子数之和
   >           return Leaves(t->fch)+Leaves(t->nsib);
   > }
   > ```

2. 以孩子兄弟链表为存储结构，请设计递归算法求树的深度。

   > 解答：
   >
   > 由孩子兄弟链表表示的树，求高度的算法思想如下：采用递归算法，若树为空，高度为零；否则，高度为第一子女树高度加1和兄弟子树高度的大者。其非递归算法使用队列，逐层遍历树，取得树的高度。算法代码如下：
   >
   > ```
   > int Height(CSTree bt){
   >      //递归求以孩子兄弟链表表示的树的深度
   >      int hc,hs;
   >      if(bt==NULL)
   >           return 0;
   >      else{   //否则，高度取子女高度加1和兄弟子树高度的大者
   >          hc=height(bt->firstchild);   //第一子女树
   >      }
   > }
   > ```
   >
   > 