1. 编写后序遍历二叉树的非递归算法

   > 解答：
   >
   > 算法思想：后序非递归遍历二叉树先是访问左子树，再访问右子树，最后访问根结点。结合图5.7来分析：1.沿着根的左孩子，依次入栈，直到左孩子为空。此时栈内元素依次为A B D。2.读栈顶元素：若其右孩子不空且未被访问过，将右子树转执行1；否则，栈顶元素出栈并访问。栈顶D的右孩子为空，出栈并访问，它是后序序列的第一个结点；栈顶B的右孩子不空且未被访问过，E入栈，栈顶E的左右孩子均为空，出栈并访问；栈顶B的右孩子不空但已被访问，B出栈并访问；栈顶A的右孩子不空且未被访问过，C入栈，栈顶C的左右孩子均为空，出栈并访问；栈顶A的右孩子不空但已被访问，A出栈并访问。由此得到后序序列为D E B C A。
   > 在上述思想的第2步中，必须分清返回时是从左子树返回的还是从右子树返回的，因此设定一个辅助指针r，指向最近访问过的结点。也可在结点中增加一个标志域，记录是否已被访问。
   >
   > ```；
   > void PostOrder(BiTree T){
   >      InitStack(S);
   >      p=T;
   >      r=NULL;
   >      while(p||!IsEmpty(S)){
   >      if(p){        //走到最左边
   >           push(S,p);
   >           p=p->lchild;
   >      }
   >      else{   //向右
   >         GetTop(S,p);   //读栈顶结点（非出栈）
   >         if(p->rchild&&p->rchild!=r){   //若右子树存在，且未被访问过
   >              p=p->rchild;   //转向右
   >              push(S,p);    //压入栈
   >              p=p->lchild;    //再走到最左
   >         }
   >         else{      //否则弹出结点并访问
   >            pop(S,p);    //将结点弹出
   >            visit(p->data);  //访问该结点
   >            r=p;    //记录最近访问过的结点
   >            p=NULL;   //结点访问完后，重置p指针
   >         }
   >      }//else
   >      }//while
   > }
   > ```
   >
   > 注意：每次出栈访问完一个结点就相当于遍历完以该结点为根的字数，需要将p置为NULL。

2. 试给出二叉树的自下而上、从右到左的层次遍历算法。

   > 解答：
   >
   > 一般的二叉树层次遍历是自上而下、从左到右，这里的遍历顺序恰好相反。算法思想：利用原有的层次遍历算法。出队的同时将各结点指针入栈，在所有结点入栈后再从栈顶开始一次访问即为所求的算法。具体实现如下：
   >
   > 1. 把根结点入队列
   >
   > 2. 把一个元素出队列，遍历这个元素
   >
   > 3. 依次把这个元素的左孩子、右孩子入队列
   >
   > 4. 若队列不空，则跳到2，否则结束
   >
   >    算法实现如下：
   > ```
   > void InvertLevel(BiTree bt){
   >    Stack s;Queue Q;
   >    if(bt!=NULL){
   >        InitStack(s);        //栈初始化，栈中存放二叉树结点的指针
   >        InitQueue(Q);    //队列初始化，队列中存放二叉树结点的指针
   >        EnQueue(Q,bt);
   >        while(IsEmpty(Q)==false){//从上而下层次遍历
   >              DeQueue(Q,p);
   >              Push(s,p);      //出队，入栈
   >              if(p->lchild)
   >                 EnQueue(Q,p->lchild);   //若左子女不空，则入队列
   >              if(p->rchild)
   >                  EnQueue(Q,p->rchild);   //若右子女不空，则入队列
   >        }
   >        while(IsEmpty(s)==false){
   >           Pop(s,p);
   >           visit(p->data);
   >        }        //自下而上、从右到左的层次遍历
   >    }//if结束
   > }
   > ```
   > 

3. 假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。

   > 解答：
   >
   > 采用层次遍历的算法，设置变量level记录当前结点所在的层数，设置变量last指向当前层的最右结点，每次层次遍历出队时与last指针比较，若两者相等，则层数加1，并让last指向下一层的最右结点，直到遍历完成。level的值即为二叉树的高度
   >
   > 算法实现如下：
   >
   > ```
   > int Btdepth(BiTree T){
   >  //采用层次遍历的非递归方法求解二叉树的高度
   >    if(!T)
   >       return 0;   //树空，高度为0
   >     int front=-1,rear=-1;
   >     int last=0,level=0;         //last指向当前层的最右结点
   >     BiTree Q[MaxSize];     //设置队列Q，元素是二叉树结点指针且容量足够
   >     Q[++rear]=T;    //将根结点入队
   >     BiTree p;
   >     while(front<rear){    //队不空,则循环
   >        p=Q[++front];   //队列元素出队，即正在访问的结点
   >      if(p->lchild)
   >         Q[++rear]=p->lchild;  //左孩子入队
   >      if(p->rchild)
   >         Q[++rear]=p->rchild;  //右孩子入队
   >      if(front==last){    //处理该层的最右结点
   >           level++1      //层数增1
   >         last=rear;     //last指向下层
   >      }
   >     }
   >     return level;
   >  }
   > ```
   >
   > 求某层的结点个数、每层的结点个数、树的最大宽度，都采用与此题类似的思想。当然，此题可编写递归算法，其实现如下：
   >
   > ```
   > int Btdepth2(BiTree T){
   >      if(T==NULL)
   >         return 0;     //空树，高度为0
   >       ldep=Btdepth2(T->lchild);//左子树高度
   >       rdep=Btdepth2(T->rchild);//右子树高度
   >       if(ldep>rdep)
   >          return ldep+1;   //树的高度为子树最大高度加跟结点
   >       else
   >         return rdep+1;
   >  }
   > ```
   >
   > 

4. 设一棵二叉树中各结点的值互不相同，其先序遍历序列和中序遍历序列分别存于两个一维数组A[1..n]和B[1...n]中，试编写算法建立该二叉树的二叉链表。

   > 解答：
   >
   > 由先序序列和中序序列可以唯一确定一课二叉树。算法的实现步骤如下。
   >
   > 1. 根据先序序列确定树的根结点。
   >
   > 2. 根据根结点在中序序列中分出二叉树的左、右子树包含哪些结点，然后根据左、右子树结点在先序序列中的次序确定子树的根结点，即回到步骤1.
   >
   >    如此重复上述步骤，直到每棵子树仅有一个结点（该子树的根结点）为止
   >
   > 算法实现如下
   >
   > ```
   > BiTree PreInCreat(ElemType A[],ElemType B[],int l1,int h1,int l2,int h2){
   >    //l1,h1为先序的第一和最后一个结点下标，l2，h2为中序的第一和最后一个结点下标
   >    //初始调用时，l1=l2=1,h1=h2=n
   >       root=(BiTNode*)malloc(sizeof(BiTNode));   //建根结点
   >       root->data=A[l1];     //根结点
   >       for(i=l2;B[i]!=root->data;i++);    //根结点在中序序列中的划分
   >       llen=i-12;     //左子树长度
   >       rlen=h2-i;     //右子树长度
   >       if(llen)       //递归建立左子树
   >           root->lchild=PreInCreat(A,B,l1+1,l1+llen,l2,l2+llen-1);
   >       else
   >           root->lchild=NULL;
   >       if(rlen)
   >            root->rchild=PreInCreat(A,B,h1-rlen+1,h1,h2-rlen+1,h2);
   >        else
   >           root->rchild=NULL;
   >         return root;  //返回根结点指针
   > }
   > ```

5. 二叉树按二叉链表形式存储，写一个判别给定二叉树是否是完全二叉树的算法。

   > 解答：
   >
   > 根据完全二叉树的定义，具有n个结点的完全二叉树与满二叉树中编号从1~n的结点一一对应。算法思想：采用层次遍历算法，将所有结点加入队列（包括空结点）。遇到空结点时，查看其后是否有非空结点。若有，则二叉树不是完全二叉树。
   >
   > 算法实现如下：
   >
   > ```
   > bool IsComplete(BiTree T){
   >     //本算法判断给定二叉树是否为完全二叉树
   >     InitQueue(Q);
   >     if(!T)
   >        return 1;     //空树为满二叉树
   >     EnQueue(Q,T);
   >     while(!IsEmpty(Q)){
   >        DeQueue(Q,p);
   >        if(p){   //结点非空，将其左、右子树入队列
   >           EnQueue(Q,p->lchild);
   >           EnQueue(Q,p->rchild);
   > }
   >     else      //结点为空，检查其后是否有非空结点
   >         while(!IsEmpty(Q)){
   >            DeQueue(Q,p);
   >            if(p)  //结点非空，则二叉树为非完全二叉树
   >                return 0;
   > }
   >     }
   >     return 1;
   > }
   > ```
   >
   > 

6. 假设二叉树采用二叉链表存储结构存储，试设计一个算法，计算一棵给定的二叉树所有双分支结点的个数。

   > 解答：
   >
   > 计算一棵二叉树b中所有双分支结点个数的递归模型f(b)如下：
   >
   > f(b)=0     若b=NULL
   >
   > f(b)=f(b->lchild)+f(b->rchild)+1    若*b为双分支结点
   >
   > f(b)=f(b->lchild)+f(b->rchild)   其他情况（*b为单分支结点或叶子结点）
   >
   > 具体算法实现如下：
   >
   >    ```
   > int DsonNode(BiTree b){
   >    if(b==NULL)
   >        return 0;
   >     else if(b->lchild!=NULL&&b->rchild!=NULL)  //双分支结点
   >         return DsonNodes(b->lchild)+DsonNodes(b->rchild)+1
   >     else
   >        return DsonNodes(b->lchild)+DsonNodes(b->rchild);
   > }
   >    ```
   >
   > 