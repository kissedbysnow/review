1. 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点

   > 解答：设f(L,x)的功能是删除以L为首结点指针的单链表中所有值等于x的结点，显然有f(L->next,x)的功能是删除以L->next为首结点指针的单链表中所有值等于x的结点。由此，可以推出递归模型如下。
   >
   > 终止条件：f(L,x)≡不做任何事情；    若L为空表
   >
   > 递归主体：f(L,x)≡删除*L结点；f(L->next,x)；若L->data==x
   >
   > ​           f(L,x)≡f(L->next,x);     其他情况
   >
   > 本题代码如下：
   >
   > ```
   > void Del_X_3(Linklist &L,ElemType x){
   >           //递归实现在单链表L中删除值为x的结点
   >           LNode *p;       //p指向待删除结点
   >           if(L==NULL)    //递归出口
   >               return;
   >           if(L->data==x){  //若L所指结点的值为x
   >           p=L;             //删除*L,并让L指向下一结点
   >           L=L->next;
   >           free(p);
   >           Del_X_3(L,x);     //递归调用
   >           }
   >           else              //若L所指结点的值不为x
   >              Del_X_3(L->next,x);   //递归调用
   > }
   > ```
   >
   > 算法需要借助一个递归工作栈，深度为O(n),时间复杂度为O(n).有读者认为直接去掉p结点会造成断链，实际上因为L为引用，是直接对原链表进行操作，因此不会断链。

2. 在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法实现上述操作。

   > 解答：
   >
   > 解法一：用p从头至尾扫描单链表，pre指向*p结点的前驱。若p所指结点的值为x，则删除，并让p移向下一个结点，否则让pre、p指针同步后移一个结点。
   >
   > 本题代码如下：
   >
   > ```
   > void Del_X_1(Linklist &L,ElemType x){
   > //L为带头结点的单链表，本算法删除L中所有值为x的结点
   >    LNode *p=L->next,*pre=L,*q//置p和pre的初始值
   >    while(p!=NULL){
   >         if(p->data==x){
   >             q=p;       //q指向该结点
   >             p=p->next;
   >             pre->next=p;     //删除*q结点
   >             free(q);         //释放*q结点的空间
   >         }
   >         else{         //否则，pre和p同步后移
   >              pre=p;
   >              p=p->next;
   >         }//else
   >    }//while
   > }
   > ```
   >
   > 本算法是在无序单链表中删除满足某种条件的所有结点，这里的条件是结点的值为x。实际上，这个条件是可以任意指定的，只要修改if条件且即可。比如，我们要求删除值介于mink和maxk之间的所有结点，则只需将if语句修改为if(p->data>mink&&p->data<maxk).
   >
   > 解法二：采用尾插法建立单链表。用p指针扫描L的所有结点，当其值不为x时，将其连接到L之后，否则将其释放。
   >
   > 本题代码如下：
   >
   > ```
   > void Del_X_2(Linklist &L,ElemType x){
   > //L为带头结点的单链表，本算法删除L中所有值为x的结点
   >  LNode *p=L->next,*r=L,*q;   //r指向尾结点，其初值为头结点
   >  while(p!=NULL){
   >       if(p->data!=x){        //*p结点值不为x时将其连接到L尾部
   >            r->next=p;
   >            r=p;
   >            p=p->next;            //继续扫描
   >       }
   >       else{      //*p结点值为x时将其释放
   >          q=p;
   >          p=p->next;      //继续扫描
   >          free(q);        //释放控件
   >       }
   >  }//while
   >  r->next=NULL;     //插入结束后置尾结点指针为NULL
   > }
   > ```
   >
   > 上述两个算法扫描一遍链表，时间复杂度为O(n),空间复杂度为O(1)

3. 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。

   > 解答：
   >
   > 考虑从头到尾输出比较简单。求解本题时，我们会很自然地想到接触上题中的链表逆置法，改变链表的方向，然后就可从头到尾实现反向输出。
   >
   > 此外，本题还可借助一个栈来实现，每经过一个结点时，将该结点放入栈中。遍历完整个链表后，再从栈顶开始输出结点值即可。这种实现方法请读者在学习完第3章后自行思考（实现时可直接使用栈的基本操作函数）。
   >
   > 既然能用栈的思想解决，我们也就很自然地联想到了用递归来实现。每当访问一个结点时，先递归输出它后面的结点，再输出该结点自身，这样链表就反向输出了。
   >
   > 本题代码如下：
   >
   > ```
   > void R_Print(LinkList L){
   > //从尾到头输出单链表L中每个结点的值
   >  if(L->next!=NULL){
   >       R_Print(L->next);//递归
   >  }//if
   >    if(L!=NULL) print(L->data);    //输出函数
   > }
   > ```
   >
   > 

4. 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小值结点是唯一的）

   > 解答：
   >
   > 算法思想：用p从头至尾扫描单链表，pre指向*P结点的前驱，用minp保存值最小的结点指针（初值为p），minpre 指向 * minp结点的前驱（初值为pre）。一边扫描，一边比较，若p->data小于minp->data，则将p、pre分别赋值给minp、minpre，当p扫描完毕,minp指向最小值结点，minpre指向最小值结点的前驱结点，再将minp所指结点删除即可。
   >
   > 本题代码如下：
   >
   > ```
   > LinkList Delete_Min(LinkList &L){
   > //L是带头结点的单链表，本算法删除其最小值结点
   >   LNode *pre=L,*p=pre->next;//p为工作指针，pre指向其前驱
   >   LNode *minpre=pre,*minp=p;//保存最小值结点及其前驱
   >   while(p!=NULL){
   >         if(p->data<minp->data){
   >         minp=p;      //找到比之前找到的最小值结点更小的结点
   >         minpre=pre;
   >         }
   >         pre=p;        //继续扫描下一结点
   >         p=p->next;
   >   }
   >   minpre->next=minp->next;//删除最小值结点
   >   free(minp);
   >   return L;
   > }
   > ```
   >
   > 算法需要从头至尾扫描链表，时间复杂度为O(n),空间复杂度为O(1).
   >
   > 若本题改为不带头结点的单链表，则实现上会有所不同，请读者自行思考。

5. 试编写算法将带头结点的单链表就地逆置，所谓“就地”是指辅助空间复杂度为O(1).

   > 解答：
   >
   > 解法一：将头结点摘下，然后从第一结点开始，依次插入到头结点的后面(头插法建立单链表)，直到最后一个结点为止，这样就实现了链表的逆置。
   >
   > 本题代码如下：
   >
   > ```
   > LinkList Reverse_1(LinkList L){
   > //L是带头结点的单链表，本算法将L就地逆置
   >     LNode *p,*r;    //p为工作指针，r为p的后继，以防断链
   >     p=L->next;     //从第一个元素结点开始
   >     L->next=NULL;        //先将头结点L的next域置为NULL
   >     while(p!=NULL){    //依次将元素结点摘下
   >            r=p->next;   //暂存p的后继
   >            p->next=L->next;  //将p结点插入到头结点之后
   >            L->next=p;
   >            p=r;
   >     }
   >     return L;
   > }
   > ```
   >
   > 解法二：大部分辅导书都只介绍解法一，这对读者的理解和思维是不利的。为了将调整指针这个复杂的过程分析清楚，我们借助图形来进行直观的分析。
   >
   > 假设pre、p和r指向3个相邻的结点。假设经过若干操作后，*pre之前的结点的指针都已调整完毕，它们的next都指向其原前驱结点。现在令 *p结点的next域指向 *pre结点，注意到一旦调整指针的指向后， *p的后继结点的链就会断开，为此需要用r来指向原 *p的后继结点。处理时需要注意两点：一是在处理第一个结点时，应将其next域置为NULL，而不是指向头结点（因为它将作为新表的尾结点）；二是在处理完最后一个结点后，需要将头结点的指针指向它。
   >
   > 本题代码如下：
   >
   > ```
   > LinkList Reverse_2(LinkList L){
   > //依次遍历线性表L，并将结点指针反转
   >    LNode *pre,*p=L->next,*r=p->next;
   >    p->next=NULL;       //处理第一个结点
   >    while(r!=NULL){     //r为空，则说明p为最后一个结点
   >         pre=p;          //依次继续遍历
   >         p=r;
   >         r=r->next;
   >         p->next=pre;      //指针反转
   >    }
   >        L->next=p;       //处理最后一个结点
   >        return L;
   > }
   > ```
   >
   > 上述两个算法的时间复杂度为O(n)，空间复杂度为O(1)。

6. 有一个带头结点的单链表L,设计一个算法使其元素递增有序。

   > 解答：
   >
   > 算法思想：采用直接插入排序算法的思想，先构成只含一个数据结点的有序单链表，然后依次扫描单链表中剩下的结点*p(直至p==NULL为止)，在有序表中通过比较查找插入 *p的前驱结点 *pre，然后将 *p插入到 *pre之后
   >
   > 本题代码如下：
   >
   > ```
   > void Sort(LinkList &L){
   >   //本算法实现将单链表L的结点重排，使其递增有序
   >      LNode *p=L->next,*pre;
   >      LNode *r=p->next;          //r保持*p后继结点指针，以保证不断链
   >      p->next=NULL;       //构造只含一个数据结点的有序表
   >      p=r;
   >      while(p!=NULL){
   >         r=p->next;      //保存*p的后继结点指针
   >         pre=L;
   >         while(pre->next!=NULL&&pre->next->data<p->data)
   >              pre=pre->next;   //在有序表中查找*P的前驱结点*pre
   >              p->next=pre->next;   //将*p插入到*pre之后
   >              pre->next=p;
   >              p=r;
   >      }
   > }
   > ```
   >
   > 该算法的时间复杂度为(n²)，为达到最佳的时间性能，可先将链表的数据复制到数组中，再采用时间复杂度为O(nlog₂n)的排序算法进行排序，然后将数组元素依次插入到链表中，此时间复杂度为O(nlog₂n)，显然这是以空间换时间的策略。

7. 设在一个带表头结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值（作为函数参数给出）之间的元素的元素（若存在）

   > 因为链表是无序的，所以只能逐个结点进行检查，执行删除。
   >
   > 本题代码如下：
   >
   > ```
   > void RangeDelete(LinkList &L,int min,int max){
   >     LNode *pr=L,*p=L->link      //p是检测指针，pr是其前驱
   >     while(p!=NULL)
   >         if(p->data>min&&p->data<max){   //寻找被删结点，删除
   >                pr->link=p->link;
   >                free(p);
   >                p=pr->link;
   >         }
   >         else{     //否则继续寻找被删结点
   >         pr=p;
   >         p=p->link
   >         }
   > }
   > ```
   >
   > 

8. 给定两个单链表，编写算法找出两个链表的公共结点。

   > 解答：
   >
   > 两个单链表有公共结点，即两个链表从某一结点开始，它们的next都指向同一个结点。由于每个单链表结点只有一个next域，因此从第一个公共结点开始，之后它们所有的结点都是重合的，不可能再出现分叉。所以两个有公共结点而部分重合的单链表，拓扑形状看起来像Y，而不可能像X。
   >
   > 本题极容易想到“蛮”方法：在第一个链表上顺序遍历每个结点，每遍历一个结点，在第二个链表上顺序遍历所有结点，若找到两个相同的结点，则找到了它们的公共结点。显然，该算法的时间复杂度为O(len1×len2)。
   >
   > 接下来我们试着去寻找一个线性时间复杂度的算法。先把问题简化：如何判断两个单向链表有没有公共结点？应注意到这样一个事实：若两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的，即它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分时，只需分别遍历两个链表到最后一个结点。若两个尾结点时一样的，则说明它们有公共结点，否则两个链表没有公共结点。
   >
   > 然而，在上面的思路中，顺序遍历两个链表到尾结点时，并不能保证在两个链表上同时到达尾结点。这是因为两个链表长度不一定一样。但假设一个链表比另一个链表长k个结点，我们先在长的链表上遍历k个结点，之后再同步遍历，此时我们就能保证同时到达最后一个结点。由于两个链表从第一个公共结点开始到链表尾结点，这一部分是重合的，因此它们也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。
   >
   > 根据这一思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历长度之差个结点之后，再同步遍历两个链表，直到找到相同的结点，或者一直到链表结束。此时，该方法的时间复杂度为O(len1+len2)。
   >
   > 本题代码如下：
   >
   > ```
   > LinkList Search_1st_Common(LinkList L1,LinkList L2){
   > //本算法实现在线性的时间内找到两个单链表的第一个公共结点
   > int len1=Length(L1),len2=Length(L2);   //计算两个链表的表长
   > LinkList longList,shortList;      //分别指向表长较长和表长较短的链表
   > if(len1>len2){     //L1表长较长
   >      longList=L1->next;shortList=L2->next;
   >      dist=len1-len2;    //表长之差
   > }
   > else{      //L2表长较长
   >      longList=L2->next;shortList=L1->next;
   >      dist=len2-len1;       //表长之差
   > }
   > while(dist--)       //表长的链表先遍历到第dist个结点，然后同步
   >   longList=longList->next;
   > while(longList!=NULL){    //同步寻找共同结点
   >     if(longList=shortList)        //找到第一个公共结点
   >      return longList;
   >     else{                   //继续同步寻找
   >        longList=longList->next;
   >        shortList=shortList->next;
   >     }
   > }//while
   > return NULL;
   > }
   > ```
   >

9. 给定一个带表头结点的单链表，设head为头指针，结点结构为(data,next)，data为整型元素，next为指针，试写出算法：按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间（要求：不允许使用数组作为辅助空间）

   > 解答：
   >
   > 算法思想：对链表进行遍历，在每次遍历中找出整个链表的最小值元素，输出并释放结点所占空间；再查找次小值元素，输出并释放空间，如此下去，直至链表为空，最后释放头结点所占存储空间。该算法的时间复杂度为O(n²)
   >
   > 本题代码如下：
   >
   > ```
   > void Min_Delete(LinkList &head){
   > //head是带头结点的单链表的头指针，本算法按递增顺序输出单链表中的数据元素
   >     while(head->next!=NULL){//循环到仅剩头结点
   >         pre=head;      //pre为元素最小值结点的前驱结点的指针
   >         p=pre->next;   //p为工作指针
   >         while(p->next!=NULL){
   >              if(p->next->data<pre->next-data)
   >              pre=p;        //记住当前最小值结点的前驱
   >              p=p->next;
   >         }
   >         print(pre->next->data);  //输出元素最小值结点的数据
   >         u=pre->next;     //删除元素值最小的结点，释放结点空间
   >         pre->next=u->next;
   >         free(u);
   >     }//while
   >     free(head);//释放头结点
   > }
   > ```
   >
   > 若题不设限制数组辅助空间的使用，则可以先将链表的数据复制在数组中，再采用时间复杂度为O(nlog₂n)的排序算法进行排序，然后将数组元素输出，时间复杂度为O(nlog₂n)

10. 将一个带头结点的单链表A分解为两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变。

    > 解答：
    >
    > 算法思想：设置一个访问序号变量（初值为0），每访问一个结点序号自动加1，然后根据序号的奇偶性将结点插入到A表或B表中。重复以上操作直到表尾。
    >
    > 本题代码如下：
    >
    > ```
    > LinkList DisCreat_1(LinkList &A){
    > //将表A中结点按序号的奇偶性分解到表A或表B中
    >       i=0;       //i记录表A中结点的序号
    >       B=(LinkList)malloc(sizeof(LNode));//创建B表表头
    >       B->next=NULL;        //B表的初始化
    >       LNode *ra=A,*rb=B;    //ra和rb分别指向创建的A表和B表的尾结点
    >       p=A->next;     //p为链表工作指针，指向待分解的结点
    >       A->next=NULL;    //置空新的A表
    >       while(p!=NULL){
    >              i++;     //序号加1
    >                 if(i%2==0){     //处理序号为偶数的链表结点
    >                     rb->next=p;     //在B表尾插入新结点
    >                     rb=p;       //rb指向新的尾结点
    >                 }
    >                 else{      //处理原序号为奇数的结点
    >                    ra->next=p;     //在A表尾插入新结点
    >                    ra=p;
    >                 }
    >                 p=p->next;    //将p恢复为指向新的待处理结点
    >       }  //while接触
    >       ra->next=NULL；
    >       rb->next=NULL；
    >       return B;
    > }
    > ```
    >
    > 为了保持原来结点中的顺序，本题采用尾插法建立单链表。此外，本算法完全可以不用设置序号变量。while循环中的代码改为将结点插入到表A中并将下一结点插入到表B中，这样while中第一处理的结点就是奇数号的点，第二处理的结点就是偶数号结点。

11. 设C={a₁,b₁,a₂,b₂,....,an,bn}为线性表，采用带头结点的hc单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A={a₁,a₂,....,an},B={bn,...,b₂,b₁,}。

    > 解答：
    >
    > 算法思想：采用上题的思路，不设序号变量。二者的差别仅在于对B表的建立不采用尾插法，而是采用头插法。
    >
    > 本题代码如下：
    >
    > ```
    > LinkList DisCreat_2(LinkList &A){
    >    LinkList B=(LinkList)malloc(sizeof(LNode));   //创建B表表头
    >    B->next=NULL;       //B表的初始化
    >    LNode *p=A->next,*q;    //p为工作指针
    >    LNode *ra=A;           //ra始终指向A的尾结点
    >    while(p!=NULL){
    >         ra->next=p;ra=p;     //将*p链到A的表尾
    >         p=p->next;
    >         if(p!=null) q=p->next;  //头插后，*p将断链，因此用q记忆*p的后继
    >         p->next=B->next;          //将*p插入到B的前端
    >         B->next=p;
    >         p=q;
    >    }
    >    ra->next=NULL;            //A尾结点的next域置空
    >    return B;
    > }
    > ```
    >
    > 该算法特别需要注意的是，采用头插法插入结点后，*p的指针域已改变，若不设置变量保存其后继结点则会引起断链，从而导致算法出错。

12. 在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素，时表中不再有重复的元素，例如（7,10,10,21,30,42,42,42,51,70）将变为（7,10,21,30,42,51,70）。

    > 解答：
    >
    > 算法思想：由于是有序表，所有相同值域的结点都是相邻的。用p扫描递增单链表L，若*p结点的值域等于其后继结点的值域，则删除后者，否则p移向下一个结点。
    >
    > 本题代码如下：
    >
    > ```
    > void Del_Same(LinkList &L){
    >    //L是递增有序的单链表，本算法删除表中数值相同的元素
    >     LNode *p=L->next,*q;      //p为扫描工作指针
    >     if(p==NULL)
    >         return;
    >      while(p->next!=NULL){
    >           q=p->next;          //q指向*p的后继结点
    >           if(p->data==q->data){      //找到重复值的结点
    >                  p->next=q->next;      //释放*q结点
    >                  free(q);           //释放相同元素值得结点
    >            }
    >           else
    >            p=p->next;
    >       }
    >       
    > }
    > ```
    >
    > 本算法的时间复杂度为O(n)，空间复杂度为O(1)。
    >
    > 本题也可采用尾插法，将头结点摘下，然后从第一结点开始，一次与已经插入结点的链表的最后一个结点比较，若不等则直接插入，否则将当前遍历的结点删除并处理下一个结点，直到最后一个结点为止。

13. 假设有两个按元素值递增次序排列的线性表，均以单链表的形式存储。请编写算法将这两个单链表归并为一个按元素值递减次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。

    > 解答：
    >
    > 算法思想：两个链表已经按元素值递增次序排序，将其合并时，均从第一个结点起进行比较，将小的结点链入链表中，同时后移工作指针。该问题要求结果链表按元素值递减次序排列，故新链表的建立应该采用头插法。比较结束后，可能会有一个链表非空，此时用头插法将剩下的结点依次插入新链表中即可。
    >
    > 本题代码如下：
    >
    > ```
    > void MergeList(LinkList &La,LinkList &Lb){
    >     //合并两个递增有序链表（带头结点），并使合并后的链表递减排列
    >     LNode *r,*pa=La->next,*pb=Lb->next;    //分别是La和Lb的工作指针
    >     La->next=NULL;        //La作为结果链表的头指针，先将结果链表初始化为空
    >     while(pa&&pb)      //当两链表均不为空时
    >         if(pa->data<=pb->data){
    >         r=pa->next;     //r暂存pa的后继结点指针
    >         pa->next=La->next;  
    >         La->next=pa;     //将pa结点链于结果表中，同时逆置（头插法）
    >         pa=r;       //恢复pa为当前比较结点
    >         }
    >         else{
    >           r=pb->next;     //r暂存pb的后继结点指针
    >           pb->next=La->next;
    >           La->next=pb;    //将pb结点链于结果表中，同时逆置（头插法）
    >           pb=r;       //恢复pb为当前比较结点
    >         }
    >       if(pa)
    >          pb=pa;          //通常情况下会剩下一个链表非空，处理剩下的部分
    >        while(pb){         //处理剩下的一个非空链表
    >             r=pb->next;      //依次插入到La中（头插法）
    >             pb->next=La->next;
    >             La->next=pb;
    >             pb=r;
    >        }
    >        free(Lb);
    > }
    > ```
    >
    > 

14. 设A和B是两个单链表（带头结点），其中元素递增有序。设计一个算法从A和B中的公共元素产生单链表C，要求不破坏A、B的结点。

    > 解答：
    >
    > 算法思想：表A、B都有序，可从第一个元素起依次比较A、B两表的元素，若元素值不等，则值小的指针往后移，若元素值相等，则创建一个值等于两结点的元素值的新结点，使用尾插法插入到新链表中，并将两个原表指针后移意味，直到其中一个链表遍历到表尾。
    >
    > 本题代码如下：
    >
    > ```
    > void Get_Common(LinkList A,LinkList B){
    > //本算法产生单链表A和单链表B的共同元素的单链表C
    >     LNode *p=A->next,*q=B->next,*r,*s;
    >     LinkList C=(LinkList)malloc(sizeof(LNode));   //建立表C
    >     r=C;                           //r始终指向C的尾结点
    >     while(p!=NULL&&q!=NULL){     //循坏跳出条件
    >            if(p->data<q->data)
    >               p=p->next;     //若A的当前元素较小，后移指针
    >            else if(p->data>q->data)
    >               q=q->next;     //若B的当前元素较小，后移指针
    >            else{
    >                s=(LNode*)malloc(sizeof(LNode));
    >                s->data=p->data;     //复制产生结点*s
    >                r->next=s;           //将*s链接到C上（尾插法）
    >                r=s;
    >                p=p->next;      //表A和B继续向后扫描
    >                q=q->next;
    >            }
    >     }
    >     r-next=NULL;         //置C尾结点指针为空
    > }
    > ```
    >
    > 

15. 已知两个链表A和B分别表示两个集合，其元素递增排列。编制函数，求A与B的交集，并存放于A链表中。

    > 解答：
    >
    > 算法思想：采用归并的思想，设置两个工作指针pa和pb，对两个链表进行归并扫描，只有同时出现在两集合中的元素才链接到结果表中且仅保留一个，其他的结点全部释放。当一个链表遍历完毕后，释放另一个表中剩下的全部结点。
    >
    > 本题代码如下：
    >
    > ```
    > LinkList Union(LinkList &la,LinkList &lb){
    >    pa=la->next;                  //设工作指针分别为pa和pb
    >    pb=lb->next;
    >    pc=la;                 //结果表中当前合并结点的前驱指针
    >    while(pa&&pb){
    >       if(pa->data=pb->data){    //交集并入结果表中
    >            pc->next=pa;       //A中结点链接到结果表
    >            pc=pa;
    >            pa=pa->next;
    >            u=pb;         //B中结点释放
    >            pb=pb->next;
    >            free(u);
    >       }
    >       else if(pa->data<pb->data){   //若A中当前结点值小于B中当前结点值
    >            u=pa;  
    >            pa=pa->next;       //后移指针
    >            free(u);             //释放A中当前结点
    >       }
    >       else{      //若B中当前结点值小于A中当前结点值
    >             u=pb;
    >             pb=pb->next;     //后移指针
    >             free(u);           //释放B中当前结点
    >       }
    >    }//while结束
    >    while(pa){    //B已遍历完，A未完
    >       u=pa;
    >       pa=pa->next;
    >       free(u);       //释放A中剩余结点
    >    }
    >    while(pb){   //A已遍历完，B未完
    >       u=pb;
    >       pb=pb->next;
    >       free(u);       //释放B中剩余结点
    >    }
    >    pc->next=NULL;    //置结果链表尾指针为NULL
    >    free(lb);     //释放B表的头结点
    >    return la;
    > }
    > ```
    >
    > 链表归并类型的试题在各学校历年真题重出现的频率很高，故应扎实掌握解决此类问题的思想。该算法的时间复杂度为O(len1+len2)，空间复杂度为O(1)。

16. 两个整数序列A=a₁,a₂,a₃,...am和B=b₁,b₂,b₃,....bn已经存入两个单链表中，设计一个算法。判断序列B是否是序列A的连续子序列。

    > 解答：
    >
    > 算法思想：因为两个整数序列已存入两个链表中，操作从两个链表的第一个结点开始，若对应数据相等，则后移指针；若对应数据不等，则A链表从上次开始比较结点的后继开始，B链表仍从第一个结点开始比较，直到B链表到尾表示匹配成功。A链表到尾而B链表未到尾表示失败。操作中应记住A链表每次的开始结点，以便下次匹配时好从其后继开始。
    >
    > 本题代码如下:
    >
    > ```
    > int Pattern(LinkList A,LinkList B){
    >   //A和B分别是数据域为整数的单链表，本算法判断B是否是A的子序列
    >    LNode *p=A;        //p为A链表的工作指针，本题假定A和B均无头结点
    >    LNode *pre=p;      //pre记住每趟比较中A链表的开始结点
    >    LNode *q=B;        //q是B链表的工作指针
    >    while(p&&q)
    >       if(p->data=q->data){    //结点值相同
    >          p=p->next;
    >          q=q->next;
    >       }
    >       else{
    >        pre=pre->next;
    >        p=pre;      //A链表新的开始比较结点
    >        q=B;        //q从B链表第一个结点开始
    >       }
    >       if(q==NULL)     //B已经比较结束
    >          return 1;     //说明B是A的子序列
    >       else
    >         return 0;      //B不是A的子序列
    > }
    > ```
    >
    > **注意**：该题其实是字符串模式匹配的链式表示形式，读者应该结合字符串模式匹配的内容重新考虑能否优化该算法。

17. 设计一个算法用于判断带头结点的循环双链表是否对称。

    > 解答：
    >
    > 算法思想：让p从左向右扫描，q从右向左扫描，直到它们指向同一结点（p==q，当循环双链表中结点个数为奇数时）或相邻（p->next=q或q->prior=p，当循环双链表中结点个数为偶数时）为止，若它们所指结点值相同，则继续进行下去，否则返回0.若比较全部相等，则返回1.
    >
    > 本题代码如下：
    >
    > ```
    > int Symmetry(DLinkList L){
    > //本算法实现从两头扫描循环双链表，以判断链表是否对称
    >   LNode   *p=L->next,*q=L->prior;   //两头工作指针
    >   while(p!=q&&q->next!=p)  //循环跳出条件
    >         if(p->data=q->data){    //所指结点值相同则继续比较
    >             p=p->next;
    >             q=q->prior;
    >         } 
    >        else      //否则，返回0
    >           return 0;
    >       return 1;    //比较结束后返回1
    > }
    > ```
    >
    > 注意：while循环第二个判断条件易误写成p->next!=q，分析这样会产生什么问题。

18. 有两个循环链表，链表头指针分别为h1和h2，编写一个函数将链表h2链接到链表h1之后，要求链接后的链表仍保持循环链表的形式。

    > 解答：
    >
    > 算法思想：先找到两个链表的尾指针，将第一个链表的尾指针与第二个链表的头结点链接起来，再使之成为循环的。
    >
    > 本题代码如下：
    >
    > ```
    > LinkList Link(LinkList &h1,LinkList &h2){
    > //将循环链表h2链接到循环链表h1之后，使之仍保持循环链表的形式
    >     LNode *p,*q;     //分别指向两个链表的尾结点
    >     p=h1;
    >     while(p->next!=h1)   //寻找h1的尾结点
    >          p=p->next;
    >      q=h2;
    >      while(q->next!=h2)   //寻找h2的尾结点
    >           q=q->next;
    >       p->next=h2;      //将h2链接到h1之后
    >       q->next=h1;      //令h2的尾结点指向h1
    >       return h1;
    > }
    > ```
    >
    > 

19. 设有一个带头结点的循环单链表。其结点值均为正整数。设计一个算法，反复找出单链表中结点值最小的结点并输出，然后将该结点从中删除，直到单链表空为止，再删除表头结点。

    > 解答：
    >
    > 对于循环单链表L，在不空时循环：每循环一次查找一个最小结点（由minp指向最小结点，minpre指向其前驱结点）并删除它。最后释放头结点。
    >
    > 本题代码如下：
    >
    > ```
    > void Del_All(LinkList &L){
    > //本算法实现每次删除循环单链表中的最小元素，直到链表空为止
    >    LNode *p,*pre,*minp,*minpre;
    >    while(L->next!=L){    //表不空，循环
    >          p=L->next;pre=L;       //p为工作指针，pre指向其前驱
    >          minp=p;minpre=pre;     //minp指向最小值结点
    >          while(p!=L){     //循环一趟，查找最小值结点
    >              if(p->data<minp->data){
    >                  minp=p;         //找到值更小结点
    >                  minpre=pre;
    >              }
    >              pre=p;       //查找下一个结点
    >              p=p->next;
    >          }
    >          printf("%d",minp->data);    //输出最小值结点元素
    >          minpre->next=minp->next;       //最小值结点从表中“断”开
    >          free(minp);           //释放空间
    >    }
    >    free(L);         //释放头结点
    > }
    > ```
    >
    > 

20. 设头指针为L的带有表头结点的非循环双向链表，其每个结点中除有pred（前驱指针）、data(数据)和next(后继指针)域外，还有一个访问频度域freq.在链表被启用前，其值均初始化为零。每当在链表中进行一次Locate(L,x)运算时，令元素值为x的结点中freq域的值增1，并使此链表中结点保持按访问频度非增（递减）的顺序排列，同时最近访问的结点排在频度相同的结点前面，以便使频繁访问的结点总是靠近表头。试编写符合上述要求的Locate(L,x)运算的算法，该运算为函数过程，返回找到结点的地址，类型为指针型。

    > 解答：
    >
    > 此题主要考查双链表的查找、删除和插入算法
    >
    > 算法思想：首先在双向链表中查找数据值为x的结点，查到后，将结点从链表摘下，然后再顺着结点的前驱链查找该结点的插入位置（频度递减，且排在同频度的第一个，即向前找到第一个比它的频度大的结点，插入位置为该结点之后），并插入到该位置。
    >
    > 本题代码如下：
    >
    > ```
    > DLinkList Locate(DLinkList &L,ElemType x){
    >    //本算法先查找数据x，查找成功时结点的访问频度域增1
    >    //最后将该结点按频度递减插入链表中适当位置（同频度最近访问的在最前面）
    >    LNode *p=L->next,*q;      //p为工作指针，q为p的前驱，用于查找插入位置
    >    while(p&&p->data!=x)
    >     p=p->next;     //查找值为x的结点
    >    if(!p){
    >       printf("不存在值为x的结点\n");
    >       exit(0);
    >    }
    >    else{
    >        p->freq++;    //令元素值为x的结点的freq域加1
    >        if(p->next!=NULL) p->next->pred=p->pred;
    >        p->pred->next=p->next;    //将p结点从链表上摘下
    >        q=p->pred;    //以下查找p结点的插入位置
    >        while(q!=L&&q->freq<=p->freq)
    >            q=q->pred;
    >        p->next=q->next;
    >        q->next->pred=p;    //将p结点插入，一定是排在同频率的第一个
    >        p->pred=q;
    >        q->next=p;
    >    }
    >    return p;     //返回值为x的结点的指针
    > }
    > ```
    >
    > 

21. 【2009统考真题】已知一个带有表头结点的单链表，结点结构为 

    | data | link |
    | ---- | ---- |
    |      |      |

    假设该链表只给了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0.要求：
    
    1. 描述算法的基本设计思想。
    2. 描述算法的详细实现步骤。
    3. 根据设计思想和实现步骤，采用程序设计语言描述算法（使用C、C++或Java语言实现），关键之处请给出简要注释。
    
    > 解答：
    >
    > 1. 算法的基本设计思想如下：
    >
    >    > 问题的关键是设计一个尽可能高效的算法，通过链表的一次遍历，找到倒数第k个结点的位置。算法的基本设计思想是：定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。以上过程对链表仅进行一遍扫描。
    >    
    > 2. 算法的详细实现步骤如下：
    >
    >    > 1. count=0,p和q指向链表表头结点的下一个结点。
    >    > 2. 若p为空，转5.
    >    > 3. 若count等于k，则q指向下一个结点；否则，count=count+1.
    >    > 4. p指向下一个结点，转2
    >    > 5. 若count等于k，则查找成功，输出该结点的data域的值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0.
    >    > 6. 算法结束。
    >    
    > 3. 算法实现如下：
    >
    >    > ```
    >    > typedef int ElemType;    //链表数据的类型定义
    >    > typedef struct LNode{     //链表结点的结构定义
    >    >      ElemType data;        //结点数据
    >    >      struct LNode *link;    //结点链接指针
    >    > }LNode,*LinkList;
    >    > int Search_k(LinkList list,int k){
    >    > //查找链表list倒数第k个结点，并输出该结点data域的值
    >    >   LNode *p=list->link,*q=list->link;    //指针p、q指示第一个结点
    >    >   int count=0;
    >    >   while(p!=NULL){      //遍历链表直到最后一个结点
    >    >        if(count<k) count++;   //计数，若count<k只移动p
    >    >        else q=q->link;
    >    >             p=p->link;      //之后，让p、q同步移动
    >    >   }//while
    >    >    if(count<k)
    >    >        return 0;    //查找失败返回0
    >    >    else{         //否则打印并返回1
    >    >        printf("%d",q->data);
    >    >        return 1;
    >    >    }
    >    > }//Search_k
    >    > ```
    > 
    > **评分说明：**若所给出的算法采用一遍扫描方式就能得到正确结果，可给满分15分；若采用两遍或多遍扫描才能得到正确结果，最高分为10分。若采用递归算法得到正确结果，最高给10分；若实现算法的空间复杂度过高（使用了大小与k有关的辅助数组），但结果正确，最高给10分。

22. 【2012统考真题】假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如，“loading”和“being”的存储映像如下图所示。

    设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为

    | data | link |
    | ---- | ---- |
    |      |      |

    请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置（如图中字符i所在结点的位置p）。要求：

    1. 给出算法的基本设计思想
    2. 根据设计思想，采用C或C++或Java语言描述算法，关键之处会给出注释。
    3. 说明你所设计算法的时间复杂度。
    > 解答：
    >
    > 本题的结构体是单链表，采用双指针法。用指针p、q分别扫描str1、str2，当p、q指向同一个地址时，即找到共同后缀的起始位置
    >
    > 1. 算法的基本设计思想如下：
    >
    >    > 1. 分别求出str1和str2所指的两个链表的长度m和n
    >    > 2. 将两个链表以表尾对齐：令指针p、q分别指向str1和str2的头结点，若m>=n，则指针p先走，使p指向链表中的第m-n+1个结点；若m<n，则使q指向链表中的第n-m+1个结点，即使指针p和q所指的结点到表尾的长度相等。
    >    > 3. 反复将指针p和q同步向后移动，当p、q指向同一位置时停止，即为共同后缀的起始位置，算法结束。
    >    
    > 2. 本题代码如下
    >
    >    > ````
    >    > typedef struct Node{
    >    >     char data;
    >    >     struct Node *next;
    >    > }SNode;
    >    > /*求链表长度的函数*/
    >    > int listlen(SNode *head){
    >    >      int len=0;
    >    >      while(head->next!=NULL){
    >    >        len++;
    >    >        head=head->next;
    >    >      }
    >    >      return len;
    >    > }
    >    > /*找出共同后缀的起始地址*/
    >    > SNode* find_addr(SNode *str1,SNode *str2){
    >    >         int m,n;
    >    >         SNode *p,*q;
    >    >         m=listlen(str1);    //求str1的长度
    >    >         n=listlen(str2);    //求str2的长度
    >    >         for(p=str1;m>n;m--)   //若m>n，使p指向链表中的第m-n+1个结点
    >    >               p=p->next;
    >    >         for(q=str2;m<n;n--)   //若m<n，使q指向链表中的第n-m+1个结点
    >    >               q=q->next;
    >    >         while(p->next!=NULL&&p->next!=q->next){  //将指针p和q同步向后移动
    >    >             p=p->next;
    >    >             q=q->next;
    >    >         }//while
    >    >             return p->next;    //返回共同后缀的起始地址
    >    > }
    >    > ````
    >    >
    > 3. 时间复杂度为O(len1+len2)或O(max(len1,len2)),其中len1、len2分别为两个链表的长度。

23. 【2015统考真题】用单链表保存m个整数，结点的结构为[data] [link]，且|data|<=n(n为正整数)。先要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。

    要求：

    1. 给出算法的基本设计思想。
    2. 使用C或C++语言，给出单链表结点的数据类型定义
    3. 根据设计思想，采用C或C++语言描述算法，关键之处给出注释。
    4. 说明你所设计算法的时间复杂度和空间复杂度。

    > 解答：
    >
    > 1. 算法的基本设计思想：
    >   >  1. 算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。
    >   >  2. 因为|data|<=n,故辅助数组q的大小为n+1,各元素的初值均为0.依次扫描链表中的各结点，同时检查q[|data|]的值，若为0则保留该节点，并令q[|data|]=1；否则将该节点从链表中删除。
    >
    > 2. 使用C语言描述的单链表结点的数据类型定义：
    > 	> ```
    >    > typedef struct node{
    >    >    int data;
    >    >    struct node *link'
    >    > }NODE;
    >    > Typedef NODE *PNODE;
    >    > ```
    >    >
    >    
    > 3. 算法实现如下：
    >    
    >    > ```
    >    > void func (PNODE h,int n){
    >    >     PNODE p=h,r;
    >    >     int *q,m;
    >    >     q=(int *)malloc(sizeof(int)*(n+1));   //申请n+1个位置的辅助空间
    >    >     for(int i=0;i<n+1;i++)       //数组元素初值为0
    >    >          *(q+i)=0;
    >    >      while(p->link!=NULL){
    >    >          m=p->link->data>0? p->link->data:-p->link->data;
    >    >          if(*(q+m)==0)         //判断该结点的data是否已经出现过
    >    >          {
    >    >          *(q+m)=1;         //首次出现
    >    >          p=p->link;          //保留
    >    >          }
    >    >          else{              //重复出现
    >    >           r=p->link;         //删除
    >    >           p->link=r->link;
    >    >           free(r);
    >    >          }
    >    >      }
    >    >      free(q);
    >    > }
    >    > ```
    >    >
    > 4. 参考答案所给算法的时间复杂度为O(m)，空间复杂度为O(n).

24. 设计一个算法完成以下功能：判断一个链表是否有环，如果有，找出环的入口点并返回，否则返回NULL。

    > 解答：
    >
    > 1. 算法的基本设计思想
    >
    >    > 设置快慢两个指针分别为fast和slow,初始时都指向表头head。slow每次走一步，即slow=slow->next;fast每次走两步，即fast=fast->next->next.由于fast比slow走得快，如果有环，fast一定会先进入环，而slow后进入环。当两个指针都进入环后，经过若干次操作后两个指针定能在环上相遇。这样就可以判断一个链表是否有环。
    >    >
    >    > 如下图所示，当slow刚进入环时，fast早已进入环。因为fast每次比slow多走一步且fast与slow的距离小于环的长度，所以fast与slow相遇时，slow所走距离不超过环的长度。
    >    >
    >    > 如下图所示，设头结点到环的入口点的距离为a,环的入口点沿着环的方向到相遇点的距离为x，环长为r，相遇时fast绕过了n圈。
    >    >
    >    > 则有2(a+x)=a+n*r+x,即a=n *r-x.显然从头结点到环的入口点的距离等于n倍的环长减去环的入口点到相遇点的距离。因此可设置两个指针，一个指向head，一个指向相遇点，两个指针同步移动(均为一次走一步)，相遇点即为环的入口点。
    >    
    > 2. 本题代码如下：
    >
    >    > ```
    >    > LNode * FindLoopStart(LNode *head){
    >    >    LNode *fast=head,*slow=head;   //设置快慢两个指针
    >    >    while(slow!=NULL&&fast->next!=NULL){
    >    >       slow=slow->next;      //每次走一步
    >    >       fast=fast->next->next;   //每次走两步
    >    >       if(slow==fast) break;   //相遇
    >    >    }
    >    >    if(slow=NULL||fast->next=NULL)
    >    >       return NULL;      //没有环，返回NULL
    >    >     LNode *p1=head,*p2=slow;   //分别指向开始点、相遇点
    >    >     while(p1!=p2){
    >    >        p1=p1->next;
    >    >        p2=p2->next;
    >    >     }
    >    >     return p1;      //返回入口点
    >    > }
    >    > ```
    >    >
    >    > 

25. 【2019统考真题】设线性链表L=(a₁,a₂,a₃,....an-2,an-1,an)采用带头结点的单链表保存，链表中的结点定义如下：

    typedef struct node{

    ​       int data;

    ​       struct node*next;

    }NODE

    请设计一个空间复杂度为O(1)且时间上尽可能高效的算法，重新排列L中的各结点，得到线性表L′=(a₁,an,a₂,an-1,a₃,an-2,...)。要求：

    1. 给出算法的基本设计思想、
    2. 根据设计思想，采用C或C++语言描述算法，关键之处给出注释。
    3. 说明你所设计的算法的时间复杂度。

    > 解答：
    >
    > 1. 算法的基本设计思想
    >
    >    > 先观察L=(a₁,a₂,a₃,....an-2,an-1,an)和L′=(a₁,an,a₂,an-1,a₃,an-2,...)，发现L′是由L摘取第一个元素，再摘取倒数第一个元素.....依次合并而成的。为了方便链表后半段取元素，需要先将L后半段原地逆置【题目要求空间复杂度为O(1)，不能借助栈】，否则每取最后一个结点都需要遍历一次链表。
    >    >
    >    > 1. 先找出链表L的中间结点，为此设置两个指针p和q，指针p每次走一步，指针q每次走两步，当指针q到达链尾时，指针p正好在链表的中间结点，
    >    > 2. 然后将L的后半段结点原地逆置
    >    > 3. 从单链表前后两段中依次各取一个结点，按要求重排。
    >    
    > 2. 算法实现：
    >
    >    > ```
    >    > void change_list(NODE *h){
    >    >     NODE *p,*q,*r,*s;
    >    >     p=q=h;
    >    >     while(q-next!=NULL)    //寻找中间结点
    >    >    {
    >    >        p=p->next;   //p走一步
    >    >        q=q->next;
    >    >        if(q->next!=NULL) q=q->next;  //q走两步
    >    >    }
    >    >    q=p->next;     //p所指结点为中间结点，q为后半段链表的首结点
    >    >    p->next=NULL;
    >    >    while(q!=NULL)    //将链表后半段逆置
    >    >    {
    >    >       r=q->next;
    >    >       q->next=p->next;
    >    >       p->next=q;
    >    >       q=r;
    >    >    }
    >    >    s=h->next;    //s指向前半段的第一个数据结点，即插入点
    >    >    q=p->next;    //q指向后半段的第一个数据结点
    >    >    p->next=NULL;
    >    >    while(q!=NULL)   //将链表后半段的结点插入到指定位置
    >    >    {
    >    >     r=q->next;    //r指向后半段的下一个结点
    >    >     q->next=s->next;  //将q所指结点插入到s所指结点之后
    >    >     s->next=q;
    >    >     s=q->next;      //s指向前半段的下一个插入点
    >    >     q=r;
    >    >     }
    >    > }
    >    > ```
    > 3. 第一步找中间结点的复杂度为O(n),第2步逆置的时间复杂度为O(n).第3步合并链表的时间复杂度为O(n),所以该算法的时间复杂度为O(n)。
    >    

## 归纳总结

本章是算法设计题的中点考查章节，因为线性表的算法题的代码量一般都比较少，又具有一定的算法设计技巧，因此适合笔试考查。考研题中常以三段式的结构命题。

在给出题目背景和要求的情况下：

1. 给出算法的基本设计思想

2. 采用C或C++语言描述算法，并给出注释。

3. 分析所设计算法的时间复杂度和空间复杂度。

算法具体的设计思想千变万化，难以从一而定。因此读者一定要勤加练习，反复咀嚼本章的练习题，采用多种方法进行设计并比较它们的复杂度，逐渐熟悉各类题型的思考角度和最佳思路。这里，编者列出几种常用的算法设计技巧，仅供参考：对于链表，经常采用的方法有头插法，尾插法，逆置法，归并法，双指针法等，对具体问题需要灵活变通；对于顺序表，由于可以直接存取，经常结合排序和查找的几种算法设计思路进行设计，如归并排序、二分查找等。

### 提示

对于算法设计题，如果能次而出数据结构类型的定义、正确的算法思想，那么至少会给一半的分数，如果能用伪代码写出自然更好，比较复杂的地方可以直接用文字表达。


