1. 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点

   > 解答：设f(L,x)的功能是删除以L为首结点指针的单链表中所有值等于x的结点，显然有f(L->next,x)的功能是删除以L->next为首结点指针的单链表中所有值等于x的结点。由此，可以推出递归模型如下。
   >
   > 终止条件：f(L,x)≡不做任何事情；    若L为空表
   >
   > 递归主体：f(L,x)≡删除*L结点；f(L->next,x)；若L->data==x
   >
   > ​           f(L,x)≡f(L->next,x);     其他情况
   >
   > 本题代码如下：
   >
   > ```
   > void Del_X_3(Linklist &L,ElemType x){
   >           //递归实现在单链表L中删除值为x的结点
   >           LNode *p;       //p指向待删除结点
   >           if(L==NULL)    //递归出口
   >               return;
   >           if(L->data==x){  //若L所指结点的值为x
   >           p=L;             //删除*L,并让L指向下一结点
   >           L=L->next;
   >           free(p);
   >           Del_X_3(L,x);     //递归调用
   >           }
   >           else              //若L所指结点的值不为x
   >              Del_X_3(L->next,x);   //递归调用
   > }
   > ```
   >
   > 算法需要借助一个递归工作栈，深度为O(n),时间复杂度为O(n).有读者认为直接去掉p结点会造成断链，实际上因为L为引用，是直接对原链表进行操作，因此不会断链。

2. 在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法实现上述操作。

   > 解答：
   >
   > 解法一：用p从头至尾扫描单链表，pre指向*p结点的前驱。若p所指结点的值为x，则删除，并让p移向下一个结点，否则让pre、p指针同步后移一个结点。
   >
   > 本题代码如下：
   >
   > ```
   > void Del_X_1(Linklist &L,ElemType x){
   > //L为带头结点的单链表，本算法删除L中所有值为x的结点
   >    LNode *p=L->next,*pre=L,*q//置p和pre的初始值
   >    while(p!=NULL){
   >         if(p->data==x){
   >             q=p;       //q指向该结点
   >             p=p->next;
   >             pre->next=p;     //删除*q结点
   >             free(q);         //释放*q结点的空间
   >         }
   >         else{         //否则，pre和p同步后移
   >              pre=p;
   >              p=p->next;
   >         }//else
   >    }//while
   > }
   > ```
   >
   > 本算法是在无序单链表中删除满足某种条件的所有结点，这里的条件是结点的值为x。实际上，这个条件是可以任意指定的，只要修改if条件且即可。比如，我们要求删除值介于mink和maxk之间的所有结点，则只需将if语句修改为if(p->data>mink&&p->data<maxk).
   >
   > 解法二：采用尾插法建立单链表。用p指针扫描L的所有结点，当其值不为x时，将其连接到L之后，否则将其释放。
   >
   > 本题代码如下：
   >
   > ```
   > void Del_X_2(Linklist &L,ElemType x){
   > //L为带头结点的单链表，本算法删除L中所有值为x的结点
   >  LNode *p=L->next,*r=L,*q;   //r指向尾结点，其初值为头结点
   >  while(p!=NULL){
   >       if(p->data!=x){        //*p结点值不为x时将其连接到L尾部
   >            r->next=p;
   >            r=p;
   >            p=p->next;            //继续扫描
   >       }
   >       else{      //*p结点值为x时将其释放
   >          q=p;
   >          p=p->next;      //继续扫描
   >          free(q);        //释放控件
   >       }
   >  }//while
   >  r->next=NULL;     //插入结束后置尾结点指针为NULL
   > }
   > ```
   >
   > 上述两个算法扫描一遍链表，时间复杂度为O(n),空间复杂度为O(1)

3. 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。

   > 解答：
   >
   > 考虑从头到尾输出比较简单。求解本题时，我们会很自然地想到接触上题中的链表逆置法，改变链表的方向，然后就可从头到尾实现反向输出。
   >
   > 此外，本题还可借助一个栈来实现，每经过一个结点时，将该结点放入栈中。遍历完整个链表后，再从栈顶开始输出结点值即可。这种实现方法请读者在学习完第3章后自行思考（实现时可直接使用栈的基本操作函数）。
   >
   > 既然能用栈的思想解决，我们也就很自然地联想到了用递归来实现。每当访问一个结点时，先递归输出它后面的结点，再输出该结点自身，这样链表就反向输出了。
   >
   > 本题代码如下：
   >
   > ```
   > void R_Print(LinkList L){
   > //从尾到头输出单链表L中每个结点的值
   >  if(L->next!=NULL){
   >       R_Print(L->next);//递归
   >  }//if
   >    if(L!=NULL) print(L->data);    //输出函数
   > }
   > ```
   >
   > 

4. 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小值结点是唯一的）

   > 解答：
   >
   > 算法思想：用p从头至尾扫描单链表，pre指向*P结点的前驱，用minp保存值最小的结点指针（初值为p），minpre 指向 * minp结点的前驱（初值为pre）。一边扫描，一边比较，若p->data小于minp->data，则将p、pre分别赋值给minp、minpre，当p扫描完毕,minp指向最小值结点，minpre指向最小值结点的前驱结点，再将minp所指结点删除即可。
   >
   > 本题代码如下：
   >
   > ```
   > LinkList Delete_Min(LinkList &L){
   > //L是带头结点的单链表，本算法删除其最小值结点
   >   LNode *pre=L,*p=pre->next;//p为工作指针，pre指向其前驱
   >   LNode *minpre=pre,*minp=p;//保存最小值结点及其前驱
   >   while(p!=NULL){
   >         if(p->data<minp->data){
   >         minp=p;      //找到比之前找到的最小值结点更小的结点
   >         minpre=pre;
   >         }
   >         pre=p;        //继续扫描下一结点
   >         p=p->next;
   >   }
   >   minpre->next=minp->next;//删除最小值结点
   >   free(minp);
   >   return L;
   > }
   > ```
   >
   > 算法需要从头至尾扫描链表，时间复杂度为O(n),空间复杂度为O(1).
   >
   > 若本题改为不带头结点的单链表，则实现上会有所不同，请读者自行思考。

5. 试编写算法将带头结点的单链表就地逆置，所谓“就地”是指辅助空间复杂度为O(1).

   > 解答：
   >
   > 解法一：将头结点摘下，然后从第一结点开始，依次插入到头结点的后面(头插法建立单链表)，直到最后一个结点为止，这样就实现了链表的逆置。
   >
   > 本题代码如下：
   >
   > ```
   > LinkList Reverse_1(LinkList L){
   > //L是带头结点的单链表，本算法将L就地逆置
   >     LNode *p,*r;    //p为工作指针，r为p的后继，以防断链
   >     p=L->next;     //从第一个元素结点开始
   >     L->next=NULL;        //先将头结点L的next域置为NULL
   >     while(p!=NULL){    //依次将元素结点摘下
   >            r=p->next;   //暂存p的后继
   >            p->next=L->next;  //将p结点插入到头结点之后
   >            L->next=p;
   >            p=r;
   >     }
   >     return L;
   > }
   > ```
   >
   > 解法二：大部分辅导书都只介绍解法一，这对读者的理解和思维是不利的。为了将调整指针这个复杂的过程分析清楚，我们借助图形来进行直观的分析。
   >
   > 假设pre、p和r指向3个相邻的结点。假设经过若干操作后，*pre之前的结点的指针都已调整完毕，它们的next都指向其原前驱结点。现在令 *p结点的next域指向 *pre结点，注意到一旦调整指针的指向后， *p的后继结点的链就会断开，为此需要用r来指向原 *p的后继结点。处理时需要注意两点：一是在处理第一个结点时，应将其next域置为NULL，而不是指向头结点（因为它将作为新表的尾结点）；二是在处理完最后一个结点后，需要将头结点的指针指向它。
   >
   > 本题代码如下：
   >
   > ```
   > LinkList Reverse_2(LinkList L){
   > //依次遍历线性表L，并将结点指针反转
   >    LNode *pre,*p=L->next,*r=p->next;
   >    p->next=NULL;       //处理第一个结点
   >    while(r!=NULL){     //r为空，则说明p为最后一个结点
   >         pre=p;          //依次继续遍历
   >         p=r;
   >         r=r->next;
   >         p->next=pre;      //指针反转
   >    }
   >        L->next=p;       //处理最后一个结点
   >        return L;
   > }
   > ```
   >
   > 上述两个算法的时间复杂度为O(n)，空间复杂度为O(1)。

6. 有一个带头结点的单链表L,设计一个算法使其元素递增有序。

   > 解答：
   >
   > 算法思想：采用直接插入排序算法的思想，先构成只含一个数据结点的有序单链表，然后依次扫描单链表中剩下的结点*p(直至p==NULL为止)，在有序表中通过比较查找插入 *p的前驱结点 *pre，然后将 *p插入到 *pre之后
   >
   > 本题代码如下：
   >
   > ```
   > void Sort(LinkList &L){
   >   //本算法实现将单链表L的结点重排，使其递增有序
   >      LNode *p=L->next,*pre;
   >      LNode *r=p->next;          //r保持*p后继结点指针，以保证不断链
   >      p->next=NULL;       //构造只含一个数据结点的有序表
   >      p=r;
   >      while(p!=NULL){
   >         r=p->next;      //保存*p的后继结点指针
   >         pre=L;
   >         while(pre->next!=NULL&&pre->next->data<p->data)
   >              pre=pre->next;   //在有序表中查找*P的前驱结点*pre
   >              p->next=pre->next;   //将*p插入到*pre之后
   >              pre->next=p;
   >              p=r;
   >      }
   > }
   > ```
   >
   > 该算法的时间复杂度为(n²)，为达到最佳的时间性能，可先将链表的数据复制到数组中，再采用时间复杂度为O(nlog₂n)的排序算法进行排序，然后将数组元素依次插入到链表中，此时间复杂度为O(nlog₂n)，显然这是以空间换时间的策略。

7. 设在一个带表头结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值（作为函数参数给出）之间的元素的元素（若存在）

   > 因为链表是无序的，所以只能逐个结点进行检查，执行删除。
   >
   > 本题代码如下：
   >
   > ```
   > void RangeDelete(LinkList &L,int min,int max){
   >     LNode *pr=L,*p=L->link      //p是检测指针，pr是其前驱
   >     while(p!=NULL)
   >         if(p->data>min&&p->data<max){   //寻找被删结点，删除
   >                pr->link=p->link;
   >                free(p);
   >                p=pr->link;
   >         }
   >         else{     //否则继续寻找被删结点
   >         pr=p;
   >         p=p->link
   >         }
   > }
   > ```
   >
   > 

8. 给定两个单链表，编写算法找出两个链表的公共结点。

   > 解答：
   >
   > 两个单链表有公共结点，即两个链表从某一结点开始，它们的next都指向同一个结点。由于每个单链表结点只有一个next域，因此从第一个公共结点开始，之后它们所有的结点都是重合的，不可能再出现分叉。所以两个有公共结点而部分重合的单链表，拓扑形状看起来像Y，而不可能像X。
   >
   > 本题极容易想到“蛮”方法：在第一个链表上顺序遍历每个结点，每遍历一个结点，在第二个链表上顺序遍历所有结点，若找到两个相同的结点，则找到了它们的公共结点。显然，该算法的时间复杂度为O(len1×len2)。
   >
   > 接下来我们试着去寻找一个线性时间复杂度的算法。先把问题简化：如何判断两个单向链表有没有公共结点？应注意到这样一个事实：若两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的，即它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分时，只需分别遍历两个链表到最后一个结点。若两个尾结点时一样的，则说明它们有公共结点，否则两个链表没有公共结点。
   >
   > 然而，在上面的思路中，顺序遍历两个链表到尾结点时，并不能保证在两个链表上同时到达尾结点。这是因为两个链表长度不一定一样。但假设一个链表比另一个链表长k个结点，我们先在长的链表上遍历k个结点，之后再同步遍历，此时我们就能保证同时到达最后一个结点。由于两个链表从第一个公共结点开始到链表尾结点，这一部分是重合的，因此它们也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。
   >
   > 根据这一思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历长度之差个结点之后，再同步遍历两个链表，直到找到相同的结点，或者一直到链表结束。此时，该方法的时间复杂度为O(len1+len2)。
   >
   > 本题代码如下：
   >
   > ```
   > LinkList Search_1st_Common(LinkList L1,LinkList L2){
   > //本算法实现在线性的时间内找到两个单链表的第一个公共结点
   > int len1=Length(L1),len2=Length(L2);   //计算两个链表的表长
   > LinkList longList,shortList;      //分别指向表长较长和表长较短的链表
   > if(len1>len2){     //L1表长较长
   >      longList=L1->next;shortList=L2->next;
   >      dist=len1-len2;    //表长之差
   > }
   > else{      //L2表长较长
   >      longList=L2->next;shortList=L1->next;
   >      dist=len2-len1;       //表长之差
   > }
   > while(dist--)       //表长的链表先遍历到第dist个结点，然后同步
   >   longList=longList->next;
   > while(longList!=NULL){    //同步寻找共同结点
   >     if(longList=shortList)        //找到第一个公共结点
   >      return longList;
   >     else{                   //继续同步寻找
   >        longList=longList->next;
   >        shortList=shortList->next;
   >     }
   > }//while
   > return NULL;
   > }
   > ```
   >

9. 给定一个带表头结点的单链表，设head为头指针，结点结构为(data,next)，data为整型元素，next为指针，试写出算法：按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间（要求：不允许使用数组作为辅助空间）

   > 解答：
   >
   > 算法思想：对链表进行遍历，在每次遍历中找出整个链表的最小值元素，输出并释放结点所占空间；再查找次小值元素，输出并释放空间，如此下去，直至链表为空，最后释放头结点所占存储空间。该算法的时间复杂度为O(n²)
   >
   > 本题代码如下：
   >
   > ```
   > void Min_Delete(LinkList &head){
   > //head是带头结点的单链表的头指针，本算法按递增顺序输出单链表中的数据元素
   >     while(head->next!=NULL){//循环到仅剩头结点
   >         pre=head;      //pre为元素最小值结点的前驱结点的指针
   >         p=pre->next;   //p为工作指针
   >         while(p->next!=NULL){
   >              if(p->next->data<pre->next-data)
   >              pre=p;        //记住当前最小值结点的前驱
   >              p=p->next;
   >         }
   >         print(pre->next->data);  //输出元素最小值结点的数据
   >         u=pre->next;     //删除元素值最小的结点，释放结点空间
   >         pre->next=u->next;
   >         free(u);
   >     }//while
   >     free(head);//释放头结点
   > }
   > ```
   >
   > 若题不设限制数组辅助空间的使用，则可以先将链表的数据复制在数组中，再采用时间复杂度为O(nlog₂n)的排序算法进行排序，然后将数组元素输出，时间复杂度为O(nlog₂n)

10. 将一个带头结点的单链表A分解为两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变。

    > 解答：
    >
    > 算法思想：设置一个访问序号变量（初值为0），每访问一个结点序号自动加1，然后根据序号的奇偶性将结点插入到A表或B表中。重复以上操作直到表尾。
    >
    > 本题代码如下：
    >
    > ```
    > LinkList DisCreat_1(LinkList &A){
    > //将表A中结点按序号的奇偶性分解到表A或表B中
    >       i=0;       //i记录表A中结点的序号
    >       B=(LinkList)malloc(sizeof(LNode));//创建B表表头
    >       B->next=NULL;        //B表的初始化
    >       LNode *ra=A,*rb=B;    //ra和rb分别指向创建的A表和B表的尾结点
    >       p=A->next;     //p为链表工作指针，指向待分解的结点
    >       A->next=NULL;    //置空新的A表
    >       while(p!=NULL){
    >              i++;     //序号加1
    >                 if(i%2==0){     //处理序号为偶数的链表结点
    >                     rb->next=p;     //在B表尾插入新结点
    >                     rb=p;       //rb指向新的尾结点
    >                 }
    >                 else{      //处理原序号为奇数的结点
    >                    ra->next=p;     //在A表尾插入新结点
    >                    ra=p;
    >                 }
    >                 p=p->next;    //将p恢复为指向新的待处理结点
    >       }  //while接触
    >       ra->next=NULL；
    >       rb->next=NULL；
    >       return B;
    > }
    > ```
    >
    > 为了保持原来结点中的顺序，本题采用尾插法建立单链表。此外，本算法完全可以不用设置序号变量。while循环中的代码改为将结点插入到表A中并将下一结点插入到表B中，这样while中第一处理的结点就是奇数号的点，第二处理的结点就是偶数号结点。

11. 设C={a₁,b₁,a₂,b₂,....,an,bn}为线性表，采用带头结点的hc单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A={a₁,a₂,....,an},B={bn,...,b₂,b₁,}。

    > 解答：
    >
    > 算法思想：采用上题的思路，不设序号变量。二者的差别仅在于对B表的建立不采用尾插法，而是采用头插法。
    >
    > 本题代码如下：
    >
    > ```
    > LinkList DisCreat_2(LinkList &A){
    >    LinkList B=(LinkList)malloc(sizeof(LNode));   //创建B表表头
    >    B->next=NULL;       //B表的初始化
    >    LNode *p=A->next,*q;    //p为工作指针
    >    LNode *ra=A;           //ra始终指向A的尾结点
    >    while(p!=NULL){
    >         ra->next=p;ra=p;     //将*p链到A的表尾
    >         p=p->next;
    >         if(p!=null) q=p->next;  //头插后，*p将断链，因此用q记忆*p的后继
    >         p->next=B->next;          //将*p插入到B的前端
    >         B->next=p;
    >         p=q;
    >    }
    >    ra->next=NULL;            //A尾结点的next域置空
    >    return B;
    > }
    > ```
    >
    > 该算法特别需要注意的是，采用头插法插入结点后，*p的指针域已改变，若不设置变量保存其后继结点则会引起断链，从而导致算法出错。

12. 在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素，时表中不再有重复的元素，例如（7,10,10,21,30,42,42,42,51,70）将变为（7,10,21,30,42,51,70）。

    > 解答：
    >
    > 算法思想：由于是有序表，所有相同值域的结点都是相邻的。用p扫描递增单链表L，若*p结点的值域等于其后继结点的值域，则删除后者，否则p移向下一个结点。
    >
    > 本题代码如下：
    >
    > ```
    > void Del_Same(LinkList &L){
    >    //L是递增有序的单链表，本算法删除表中数值相同的元素
    >     LNode *p=L->next,*q;      //p为扫描工作指针
    >     if(p==NULL)
    >         return;
    >      while(p->next!=NULL){
    >           q=p->next;          //q指向*p的后继结点
    >           if(p->data==q->data){      //找到重复值的结点
    >                  p->next=q->next;      //释放*q结点
    >                  free(q);           //释放相同元素值得结点
    >            }
    >           else
    >            p=p->next;
    >       }
    >       
    > }
    > ```
    >
    > 本算法的时间复杂度为O(n)，空间复杂度为O(1)。
    >
    > 本题也可采用尾插法，将头结点摘下，然后从第一结点开始，一次与已经插入结点的链表的最后一个结点比较，若不等则直接插入，否则将当前遍历的结点删除并处理下一个结点，直到最后一个结点为止。

13. 假设有两个按元素值递增次序排列的线性表，均以单链表的形式存储。请编写算法将这两个单链表归并为一个按元素值递减次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。

    > 解答：
    >
    > 算法思想：两个链表已经按元素值递增次序排序，将其合并时，均从第一个结点起进行比较，将小的结点链入链表中，同时后移工作指针。该问题要求结果链表按元素值递减次序排列，故新链表的建立应该采用头插法。比较结束后，可能会有一个链表非空，此时用头插法将剩下的结点依次插入新链表中即可。
    >
    > 本题代码如下：
    >
    > ```
    > void MergeList(LinkList &La,LinkList &Lb){
    >     //合并两个递增有序链表（带头结点），并使合并后的链表递减排列
    >     LNode *r,*pa=La->next,*pb=Lb->next;    //分别是La和Lb的工作指针
    >     La->next=NULL;        //La作为结果链表的头指针，先将结果链表初始化为空
    >     while(pa&&pb)      //当两链表均不为空时
    >         if(pa->data<=pb->data){
    >         r=pa->next;     //r暂存pa的后继结点指针
    >         pa->next=La->next;  
    >         La->next=pa;     //将pa结点链于结果表中，同时逆置（头插法）
    >         pa=r;       //恢复pa为当前比较结点
    >         }
    >         else{
    >           r=pb->next;     //r暂存pb的后继结点指针
    >           pb->next=La->next;
    >           La->next=pb;    //将pb结点链于结果表中，同时逆置（头插法）
    >           pb=r;       //恢复pb为当前比较结点
    >         }
    >       if(pa)
    >          pb=pa;          //通常情况下会剩下一个链表非空，处理剩下的部分
    >        while(pb){         //处理剩下的一个非空链表
    >             r=pb->next;      //依次插入到La中（头插法）
    >             pb->next=La->next;
    >             La->next=pb;
    >             pb=r;
    >        }
    >        free(Lb);
    > }
    > ```
    >
    > 