1. 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点

   > 解答：设f(L,x)的功能是删除以L为首结点指针的单链表中所有值等于x的结点，显然有f(L->next,x)的功能是删除以L->next为首结点指针的单链表中所有值等于x的结点。由此，可以推出递归模型如下。
   >
   > 终止条件：f(L,x)≡不做任何事情；    若L为空表
   >
   > 递归主体：f(L,x)≡删除*L结点；f(L->next,x)；若L->data==x
   >
   > ​           f(L,x)≡f(L->next,x);     其他情况
   >
   > 本题代码如下：
   >
   > ```
   > void Del_X_3(Linklist &L,ElemType x){
   >           //递归实现在单链表L中删除值为x的结点
   >           LNode *p;       //p指向待删除结点
   >           if(L==NULL)    //递归出口
   >               return;
   >           if(L->data==x){  //若L所指结点的值为x
   >           p=L;             //删除*L,并让L指向下一结点
   >           L=L->next;
   >           free(p);
   >           Del_X_3(L,x);     //递归调用
   >           }
   >           else              //若L所指结点的值不为x
   >              Del_X_3(L->next,x);   //递归调用
   > }
   > ```
   >
   > 算法需要借助一个递归工作栈，深度为O(n),时间复杂度为O(n).有读者认为直接去掉p结点会造成断链，实际上因为L为引用，是直接对原链表进行操作，因此不会断链。

2. 在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法实现上述操作。

   > 解答：
   >
   > 解法一：用p从头至尾扫描单链表，pre指向*p结点的前驱。若p所指结点的值为x，则删除，并让p移向下一个结点，否则让pre、p指针同步后移一个结点。
   >
   > 本题代码如下：
   >
   > ```
   > void Del_X_1(Linklist &L,ElemType x){
   > //L为带头结点的单链表，本算法删除L中所有值为x的结点
   >    LNode *p=L->next,*pre=L,*q//置p和pre的初始值
   >    while(p!=NULL){
   >         if(p->data==x){
   >             q=p;       //q指向该结点
   >             p=p->next;
   >             pre->next=p;     //删除*q结点
   >             free(q);         //释放*q结点的空间
   >         }
   >         else{         //否则，pre和p同步后移
   >              pre=p;
   >              p=p->next;
   >         }//else
   >    }//while
   > }
   > ```
   >
   > 本算法是在无序单链表中删除满足某种条件的所有结点，这里的条件是结点的值为x。实际上，这个条件是可以任意指定的，只要修改if条件且即可。比如，我们要求删除值介于mink和maxk之间的所有结点，则只需将if语句修改为if(p->data>mink&&p->data<maxk).
   >
   > 解法二：采用尾插法建立单链表。用p指针扫描L的所有结点，当其值不为x时，将其连接到L之后，否则将其释放。
   >
   > 本题代码如下：
   >
   > ```
   > void Del_X_2(Linklist &L,ElemType x){
   > //L为带头结点的单链表，本算法删除L中所有值为x的结点
   >  LNode *p=L->next,*r=L,*q;   //r指向尾结点，其初值为头结点
   >  while(p!=NULL){
   >       if(p->data!=x){        //*p结点值不为x时将其连接到L尾部
   >            r->next=p;
   >            r=p;
   >            p=p->next;            //继续扫描
   >       }
   >       else{      //*p结点值为x时将其释放
   >          q=p;
   >          p=p->next;      //继续扫描
   >          free(q);        //释放控件
   >       }
   >  }//while
   >  r->next=NULL;     //插入结束后置尾结点指针为NULL
   > }
   > ```
   >
   > 上述两个算法扫描一遍链表，时间复杂度为O(n),空间复杂度为O(1)

3. 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。

   > 解答：
   >
   > 考虑从头到尾输出比较简单。求解本题时，我们会很自然地想到接触上题中的链表逆置法，改变链表的方向，然后就可从头到尾实现反向输出。
   >
   > 此外，本题还可借助一个栈来实现，每经过一个结点时，将该结点放入栈中。遍历完整个链表后，再从栈顶开始输出结点值即可。这种实现方法请读者在学习完第3章后自行思考（实现时可直接使用栈的基本操作函数）。
   >
   > 既然能用栈的思想解决，我们也就很自然地联想到了用递归来实现。每当访问一个结点时，先递归输出它后面的结点，再输出该结点自身，这样链表就反向输出了。
   >
   > 本题代码如下：
   >
   > ```
   > void R_Print(LinkList L){
   > //从尾到头输出单链表L中每个结点的值
   >  if(L->next!=NULL){
   >       R_Print(L->next);//递归
   >  }//if
   >    if(L!=NULL) print(L->data);    //输出函数
   > }
   > ```
   >
   > 

4. 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小值结点是唯一的）

   > 解答：
   >
   > 算法思想：用p从头至尾扫描单链表，pre指向*P结点的前驱，用minp保存值最小的结点指针（初值为p），minpre 指向 * minp结点的前驱（初值为pre）。一边扫描，一边比较，若p->data小于minp->data，则将p、pre分别赋值给minp、minpre，当p扫描完毕,minp指向最小值结点，minpre指向最小值结点的前驱结点，再将minp所指结点删除即可。
   >
   > 本题代码如下：
   >
   > ```
   > LinkList Delete_Min(LinkList &L){
   > //L是带头结点的单链表，本算法删除其最小值结点
   >   LNode *pre=L,*p=pre->next;//p为工作指针，pre指向其前驱
   >   LNode *minpre=pre,*minp=p;//保存最小值结点及其前驱
   >   while(p!=NULL){
   >         if(p->data<minp->data){
   >         minp=p;      //找到比之前找到的最小值结点更小的结点
   >         minpre=pre;
   >         }
   >         pre=p;        //继续扫描下一结点
   >         p=p->next;
   >   }
   >   minpre->next=minp->next;//删除最小值结点
   >   free(minp);
   >   return L;
   > }
   > ```
   >
   > 算法需要从头至尾扫描链表，时间复杂度为O(n),空间复杂度为O(1).
   >
   > 若本题改为不带头结点的单链表，则实现上会有所不同，请读者自行思考。