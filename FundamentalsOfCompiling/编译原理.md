## 一、引论

|        |                                    |
| ------ | ---------------------------------- |
| 宿主机 | 运行编译程序的计算机               |
| 目标机 | 运行编译程序所产生目标代码的计算机 |

小结：

1. 语言程序分为：**汇编**语言程序和**高级**语言程序
2. 高级语言处理程序按翻译方式分为：**编译**程序和**解释**程序，区别：是否生成目标代码
3. 编译程序是这样一种程序，把源语言程序转化成目标语言程序

## 二、高级语言及其语法描述

### 2.1 上下文无关文法

|              |                                    |
| ------------ | ---------------------------------- |
| 文法         | 描述语言的语法结构的形式规则       |
| 上下文无关法 | 定义的语法范畴完全独立于出现的环境 |

上下文无关文法 G = ( VT，VN，S，P )

|      |                      |                                  |
| ---- | -------------------- | -------------------------------- |
| VT   | 终结符集合（非空）   |                                  |
| VN   | 非终结符集合（非空） | VT ∩ Vn = Ø                      |
| S    | 文法的开始符号       | S ∈ VN                           |
| P    | 产生式集合（有限）   | P → α，P ∈ VN，α ∈ ( VT ∪ VN ) * |

开始符 S 至少必须在某个产生式的左部出现一次

### 2.2 推导

G **文法**，S **开始符号**

- if S *⇨ α，则称 α 是一个[句型]()

- 仅含终结符号的[句型]()是一个句子

- **文法** G 所产生的句子的全体是一个[语言 L(G)]()

---

由**文法**求[语言]()：

> G(A): A → c|Ab

A ⇨ c

A ⇨ Ab ⇨ c b

A ⇨ Ab ⇨ cb b

L(G)={ c,cb,cbb,... }

---

由[语言]()求**文法**：

> L(G)={ a^n * b^n | n >= 1 }

n=1,ab

n=2,a[ab]()b

n=3,aa[ab]()bb

G(s): S → ab|aSb

### 2.3 语法分析树与二义性

一颗语法树是不同推导过程的共性抽象

定义：

- 如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的
- 也就是说，若一个文法中存在某个句子，它有两个不同的最左（最右）推导，则这个文法是二义的

例题：

> 令文法为：
>
> E → T | E+T | E-T
>
> T → F | T*F | T/F
>
> F → (E) | i
>
> 1. 给出 **i + i * i** 、**i * ( i + i )** 的最左推导和最右推导 
>
>    |                   | 最左推导                                                     | 最右推导                                                     |
>    | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
>    | **i + i * i**     | E => [E + T]()<br />E => [T]() + T<br />E => [F]() + T<br />E => [i]() + T<br />E => i + [T * F]()<br />E => i + [F]() * F<br />E => i + [i]() * F<br />E => i + i * [i]() | E => [E + T]()<br />E => E + [T * F]()<br />E => E + T * [i]()<br />E => E + [F]() * i<br />E => E + [i]() * i<br />E => [T]() + i * i<br />E => [F]() + i * i<br />E => [i]() + i * i |
>    | **i * ( i + i )** | E => [T]()<br />E => [T * F]()<br />E => [F]() * F<br />E => [i]() * F<br />E => i * [(E)]()<br />E => i * [(E + T)]()<br />E => i * ([T]() + T)<br />E => i * ([F]() + T)<br />E => i * ([i]() + T)<br />E => i * (i + [F]())<br />E => i * (i + [i]()) | E => [T]()<br />E => [T * F]()<br />E => T * [(E)]()<br />E => T * (E + [T]())<br />E => T * (E + [F]())<br />E => T * (E + [i]())<br />E => T * ([T]() + i)<br />E => T * ([F]() + i)<br />E => T * ([i]() + i)<br />E => [F]() * (i + i)<br />E => [i]() * (i + i) |
>
> 2. 给出 **i + i + i** 、**i + i * i** 、**i - i - i** 的语法树

## 三、词法分析

### 3.1 词法分析器的输出形式

**词法分析：**从左至右逐个字符地对**源程序**进行扫描，产生一个个**单词符号**

**执行词法分析的程序：词法分析器 Lexical Analyzer** 又称**扫描器 Scanner**

> 讨论：词法分析器作为一个独立子程序
>
> 为何要将词法分析作为一个独立阶段呢？是否应该将它安排为独立的一遍呢？
>
> 答：将词法分析安排为一个独立的阶段，可以使整个编译程序结构更简洁，更条理化。词法分析比语法分析简单。它的功能是输入源程序，输出单词符号。并不用将词法分析也作为独立的一遍，即不用

### 3.2 状态转化图

状态转换图是一张**有限方向图**，节点代表**状态**，用圆圈表示

### 3.3正规表达式和有限自动机

#### 3.3.1 正规式与正规集

- **相关概念**

  - 考虑一个有穷**字母表** ∑ 字符集，其中每一个元素称为一个**字符**

  - ∑ 上的**字**（字符串）是指由 ∑ 中的字符所构成的一个有穷序列

  - 不包含任何字符的序列称为**空字**，记为 ε

  - 用 ∑* 表示 ∑ 上所有字的全体，包含空字 ε

    > 例如：设 ∑ = {a,b}，则
    >
    > ∑* = {ε,a,b,aa,bb,ab,ba,aaa,...} 即 = (a|b)*

  - ∑* 的子集 U 和 V 的[连接积]()定义为

    > UV = {αβ|α∈U & β∈V}

  - V 自身的 [n 次积]()记为

    > V^n = VV...V

  - 规定 V⁰ = {ε}，d令 `V* = V⁰ ∪ V¹ ∪ V² ∪ V³ ∪...` 称 V* 是 V 的闭包

- **正规式和正规集**，对给定的字母表 ∑

  - ε 和 Ø 都是 ∑ 上的**正规式**，它们表示的[正规集]()为 {ε} 和 Ø

  - 任何 a ∈ ∑，a 是 ∑ 上的**正规式**，他所表示的[正规集]()为 {a}

  - 假定 U 和 V 都是 ∑ 上的**正规式**，他们所表示的[正规集]()为 L(U) 和 L(V)

    | 优先级            | 运算名 | 正规式 | 正规集    |
    | ----------------- | ------ | :----- | :-------- |
    | :3rd_place_medal: | 或\|   | (U\|V) | L(U)∪L(V) |
    | :2nd_place_medal: | 连接.  | (U.V)  | L(U)L(V)  |
    | :1st_place_medal: | 闭包*  | (U)*   | (L(U))*   |

  - 例题：

    > ∑ = {a,b}
    >
    > | 正规式                   | 正规集                             |
    > | ------------------------ | ---------------------------------- |
    > | ba*                      | ∑ 上所有以 b 为首后跟任意个 a 的字 |
    > | a(a\|b)*                 | ∑ 上所有以 a 为首的字              |
    > | (a\|b)* (aa\|bb) (a\|b)* | ∑ 上所有含有 aa 或 bb 的字         |

- **正规式等价**

  - 正规集相同，则正规式等价

    > 例：b(ab)* <=> (ba)*b
    >
    > | b(ab)*                                                       | (ba)*b                                                       |
    > | ------------------------------------------------------------ | ------------------------------------------------------------ |
    > | L(b(ab)\*)<br/>= L(b) L((ab)\*)<br/>= L(b) (L(ab))\*<br/>= L(b) (L(a) L(b))\*<br/>= {b} {ab}\*<br/>= {b} {ε,ab,abab,ababab,...}<br/>= {ε.bab,babab,bababab,...} | L((ba)\*b)<br/>= L((ba)\*) L(b)<br/>= (L(ba))\* L(b)<br/>= (L(b) L(a))\* L(b)<br/>= {ba}\* {b}<br/>= {ε,ba,baba,bababa,...} {b}<br/>= {ε,bab,babab,bababab,...} |

- **正规式的性质**

  - |        | \|或运算              | .连接运算         |
    | ------ | --------------------- | ----------------- |
    | 交换律 | U\|V = V\|U           |                   |
    | 结合律 | U\|(V\|F) = (U\|V)\|F | U (VF) = (UV) F   |
    | 分配律 | U (V\|F) = UV\|UF     | (V\|F) U = VU\|FU |

  - Uε = εU = U

  - UV <> VU
  
- 测验：

  > 1. 给出下面正规表达式
  >    1. 以 01 结尾的二进制串
  >
  >       > (0|1)* 01
  >
  >    2. 含有 010 的二进制串
  >
  >       > (0|1)* 010 (0|1)*
  >
  >    3. 以 aa 或 bb 开头，以 b 结尾的由 a 和 b 组成的符号串
  >
  >       > (aa|bb) (a|b)* b
  >
  > 2. 写出以下正规式对应的正规集
  >
  >    | 正规式     | 1(0\|1)* 101               | 0\* 1 0\* 1 0\*    | (0\|1)* 10 (0\|1)* |
  >    | ---------- | -------------------------- | ------------------ | ------------------ |
  >    | **正规集** | 以1打头，101结尾的二进制串 | 包含2个1的二进制串 | 包含10的二进制串   |

#### 3.3.2 确定有限自动机（DFA）

- 一个确定有限自动机 M 是一个五元式 M = (S,∑,δ,s₀,F)

  |      |                      |                                                              |
  | ---- | -------------------- | ------------------------------------------------------------ |
  | S    | 有穷状态集           | DFA 的所有状态                                               |
  | ∑    | 输入字母表（有穷）   | 输入符号集合                                                 |
  | δ    | 状态转换函数         | 为 S×∑→S 的单值部分映射<br/>**δ(s,a)=s'** 当前行为状态为 s，输入字符为 a 时，<br/>状态转换到下一状态 s'，s' 为 s 的一个后继状态 |
  | s₀   | 开始状态（初始）     | unique，s₀∈S                                                 |
  | F    | 接收状态集合（终止） | F⊆S                                                          |

- 确定有限自动机（DFA）的表示

  - 一个 DFA 可以用一个[状态转换矩阵]()表示，矩阵的**行**表示**状态**，**列**表示**输入字符**，**矩阵元素**表示 **δ(s,a) 的值**

  - 一个 DFA　可以表示为[状态转换图]()

    假定 DFA M 含有 **m 个状态**和 **n 个输入字符**，那么，这个图含有 **m 个状态节点**，每个结点最多含有 n 条箭弧射出，且每条箭弧用 ∑ 上不同的输入字符来做标记

  例题：

  > DFA M = ({0,1,2,3} , {a,b} , f , 0 , {3})，f 定义如下：
  >
  > f(0,a)=1        f(0,b)=2
  >
  > f(1,a)=3        f(1,b)=2
  >
  > f(2,a)=1        f(2,b)=3
  >
  > f(3,a)=3        f(3,b)=3
  >
  > 1. 状态转换矩阵
  >
  >    |      |  a   |  b   |
  >    | :--: | :--: | :--: |
  >    |  0   |  1   |  2   |
  >    |  1   |  3   |  2   |
  >    |  2   |  1   |  3   |
  >    |  3   |  3   |  3   |

- 确定有限自动机（DFA）

  - 对于 ∑* 中的任何字 α，若存在一条从初态到某一终态的道路，且这条路上所有弧上的**标记符**连接成的**字**等于 α，则称 α 为 DFA M 所[识别]()（接收）
  - DFA M 所识别的**字 α **的**全体**称为该 DFA [识别（接收）的语言]()，记为 L(M)

#### 3.3.3 非确定有限自动机（NFA）

- 一个**非**确定有限自动机 M 是一个五元式 M = (S,∑,δ,s₀,F)

  |      |                          |                                  |
  | ---- | ------------------------ | -------------------------------- |
  | S    | 有穷状态集               |                                  |
  | ∑    | 输入字母表（有穷）       |                                  |
  | δ    | 状态转换函数             | 为 S×∑*→2^S 的[非]()单值部分映射 |
  | s₀   | 开始状态[集合]()（初始） | s₀[⊆]()S                         |
  | F    | 接收状态集合（终止）     | F⊆S                              |

- 区别

  |                | 确定有限自动机 DFA   | 非确定有限自动机 NFA                   |
  | -------------- | -------------------- | -------------------------------------- |
  | 弧上标志       | 只能时单个字符       | 可以是 ∑* 中的一个字，也可以是空字 ε   |
  |                |                      | 同一个字可能出现在同状态射出的多条弧上 |
| 初态不同       | 唯一的初态           | 非空初态集                             |
  | δ 映射函数不同 | S×∑→S 的单值部分映射 | S×∑*→2^S 的[非]()单值部分映射          |
  
  DFA 是 NFA 的特例

#### 3.3.4 NFA 到 DFA 的转换

- 有限自动机的等价
  - 定义：对于任何两个有限自动机 M 和 M'，如果[识别的语言相同]()即 L(M) = L(M')，则称 M 与 M' **等价**
  - 对于每一个 NFAM 存在一个 DFAM'，使得 L(M) = L(M')，即 DFA 与 NFA 描述能力相同

- **替换规则**

  ![3.3.4 替换规则](N:\Desktop\review\FundamentalsOfCompiling\images\3.3.4 替换规则.png)

- **例：**

  > ![3.3.4 替换规则-例-M转换M'](N:\Desktop\review\FundamentalsOfCompiling\images\3.3.4 替换规则-例-M转换M'.png)

- **用子集法将 M' 变换为 DFA**

  1. 设 I 是 M' 的状态集的一个子集，定义 I 的 ε- 闭包 **ε-closure(I)** 为：

     1. 若 s∈I ，则 s∈**ε-closure(I)**
     2. 若 s∈I ，则从 s 出发经过[任意条]() ε 弧而能到达的任何状态 s' 都属于 **ε-closure(I)**

     即：**ε-closure(I)** = I∪{s'|从某个状态 s∈I 出发经过[任意条]() ε 弧能到达的任何状态 s'}

  2. 设 a 是 ∑ 中的一个字符，定义 **I**a = **ε-closure(J)**

     其中，J 为 I 中某个状态出发经过**一条 a 弧**而到达的状态集合

     ![3.3.4](N:\Desktop\review\FundamentalsOfCompiling\images\3.3.4-确定化过程-0.png)

  3. 确定化的过程：

     ![3.3.4-确定化过程](N:\Desktop\review\FundamentalsOfCompiling\images\3.3.4-确定化过程-1.png)

     ![3.3.4-确定化过程-2](N:\Desktop\review\FundamentalsOfCompiling\images\3.3.4-确定化过程-2.png)

- **例：**

  > ![3.3.4-例题](N:\Desktop\review\FundamentalsOfCompiling\images\3.3.4-确定化过程-例题.png)
  >
  > | I           | Ia                                                           | Ib                                                           |
  > | ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  > | X→ε={X,5,1} | J=X→a={5,3}（不包含自身 X）<br/>**I**a=**ε-closure(J)**=J→ ε={5,3,1} | J=X→b={5,4}（不包含自身 X）<br/>**I**b=**ε-closure(J)**=J→ ε={5,4,1} |
  >
  > ![3.3.4-例题-答案](N:\Desktop\review\FundamentalsOfCompiling\images\3.3.4-确定化过程-例题-答案.png)

#### 

