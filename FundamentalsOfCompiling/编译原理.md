## 一、引论

|        |                                    |
| ------ | ---------------------------------- |
| 宿主机 | 运行编译程序的计算机               |
| 目标机 | 运行编译程序所产生目标代码的计算机 |

小结：

1. 语言程序分为：**汇编**语言程序和**高级**语言程序
2. 高级语言处理程序按翻译方式分为：**编译**程序和**解释**程序，区别：是否生成目标代码
3. 编译程序是这样一种程序，把源语言程序转化成目标语言程序

## 二、高级语言及其语法描述

### 2.1 上下文无关文法

|              |                                    |
| ------------ | ---------------------------------- |
| 文法         | 描述语言的语法结构的形式规则       |
| 上下文无关法 | 定义的语法范畴完全独立于出现的环境 |

上下文无关文法 G = ( VT，VN，S，P )

|      |                      |                                  |
| ---- | -------------------- | -------------------------------- |
| VT   | 终结符集合（非空）   |                                  |
| VN   | 非终结符集合（非空） | VT ∩ Vn = Ø                      |
| S    | 文法的开始符号       | S ∈ VN                           |
| P    | 产生式集合（有限）   | P → α，P ∈ VN，α ∈ ( VT ∪ VN ) * |

开始符 S 至少必须在某个产生式的左部出现一次

### 2.2 推导

G **文法**，S **开始符号**

- if S *⇨ α，则称 α 是一个[句型]()

- 仅含终结符号的[句型]()是一个句子

- **文法** G 所产生的句子的全体是一个[语言 L(G)]()

---

由**文法**求[语言]()：

> G(A): A → c|Ab

A ⇨ c

A ⇨ Ab ⇨ c b

A ⇨ Ab ⇨ cb b

L(G)={ c,cb,cbb,... }

---

由[语言]()求**文法**：

> L(G)={ a^n * b^n | n >= 1 }

n=1,ab

n=2,a[ab]()b

n=3,aa[ab]()bb

G(s): S → ab|aSb

### 2.3 语法分析树与二义性

一颗语法树是不同推导过程的共性抽象

定义：

- 如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的
- 也就是说，若一个文法中存在某个句子，它有两个不同的最左（最右）推导，则这个文法是二义的

例题：

> 令文法为：
>
> E → T | E+T | E-T
>
> T → F | T*F | T/F
>
> F → (E) | i
>
> 1. 给出 **i + i * i** 、**i * ( i + i )** 的最左推导和最右推导 
>
>    |                   | 最左推导                                                     | 最右推导                                                     |
>    | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
>    | **i + i * i**     | E => [E + T]()<br />E => [T]() + T<br />E => [F]() + T<br />E => [i]() + T<br />E => i + [T * F]()<br />E => i + [F]() * F<br />E => i + [i]() * F<br />E => i + i * [i]() | E => [E + T]()<br />E => E + [T * F]()<br />E => E + T * [i]()<br />E => E + [F]() * i<br />E => E + [i]() * i<br />E => [T]() + i * i<br />E => [F]() + i * i<br />E => [i]() + i * i |
>    | **i * ( i + i )** | E => [T]()<br />E => [T * F]()<br />E => [F]() * F<br />E => [i]() * F<br />E => i * [(E)]()<br />E => i * [(E + T)]()<br />E => i * ([T]() + T)<br />E => i * ([F]() + T)<br />E => i * ([i]() + T)<br />E => i * (i + [F]())<br />E => i * (i + [i]()) | E => [T]()<br />E => [T * F]()<br />E => T * [(E)]()<br />E => T * (E + [T]())<br />E => T * (E + [F]())<br />E => T * (E + [i]())<br />E => T * ([T]() + i)<br />E => T * ([F]() + i)<br />E => T * ([i]() + i)<br />E => [F]() * (i + i)<br />E => [i]() * (i + i) |
>
> 2. 给出 **i + i + i** 、**i + i * i** 、**i - i - i** 的语法树

## 三、词法分析

### 3.1 词法分析器的输出形式

**词法分析：**从左至右逐个字符地对**源程序**进行扫描，产生一个个**单词符号**

**执行词法分析的程序：词法分析器 Lexical Analyzer** 又称**扫描器 Scanner**

> 讨论：词法分析器作为一个独立子程序
>
> 为何要将词法分析作为一个独立阶段呢？是否应该将它安排为独立的一遍呢？
>
> 答：将词法分析安排为一个独立的阶段，可以使整个编译程序结构更简洁，更条理化。词法分析比语法分析简单。它的功能是输入源程序，输出单词符号。并不用将词法分析也作为独立的一遍，即不用

### 3.2 状态转化图

状态转换图是一张**有限方向图**，节点代表**状态**，用圆圈表示

### 3.3正规表达式和有限自动机

#### 3.3.1 正规式与正规集

- **相关概念**

  - 考虑一个有穷**字母表** ∑ 字符集，其中每一个元素称为一个**字符**

  - ∑ 上的**字**（字符串）是指由 ∑ 中的字符所构成的一个有穷序列

  - 不包含任何字符的序列称为**空字**，记为 ε

  - 用 ∑* 表示 ∑ 上所有字的全体，包含空字 ε

    > 例如：设 ∑ = {a,b}，则
    >
    > ∑* = {ε,a,b,aa,bb,ab,ba,aaa,...} 即 = (a|b)*

  - ∑* 的子集 U 和 V 的[连接积]()定义为

    > UV = {αβ|α∈U & β∈V}

  - V 自身的 [n 次积]()记为

    > V^n = VV...V

  - 规定 V⁰ = {ε}，d令 `V* = V⁰ ∪ V¹ ∪ V² ∪ V³ ∪...` 称 V* 是 V 的闭包

- **正规式和正规集**，对给定的字母表 ∑

  - ε 和 Ø 都是 ∑ 上的**正规式**，它们表示的[正规集]()为 {ε} 和 Ø

  - 任何 a ∈ ∑，a 是 ∑ 上的**正规式**，他所表示的[正规集]()为 {a}

  - 假定 U 和 V 都是 ∑ 上的**正规式**，他们所表示的[正规集]()为 L(U) 和 L(V)

    | 优先级            | 运算名 | 正规式 | 正规集    |
    | ----------------- | ------ | :----- | :-------- |
    | :3rd_place_medal: | 或\|   | (U\|V) | L(U)∪L(V) |
    | :2nd_place_medal: | 连接.  | (U.V)  | L(U)L(V)  |
    | :1st_place_medal: | 闭包*  | (U)*   | (L(U))*   |

  - 例题：

    > ∑ = {a,b}
    >
    > | 正规式                   | 正规集                             |
    > | ------------------------ | ---------------------------------- |
    > | ba*                      | ∑ 上所有以 b 为首后跟任意个 a 的字 |
    > | a(a\|b)*                 | ∑ 上所有以 a 为首的字              |
    > | (a\|b)* (aa\|bb) (a\|b)* | ∑ 上所有含有 aa 或 bb 的字         |

- **正规式等价**

  - 正规集相同，则正规式等价

    > 例：b(ab)* <=> (ba)*b
    >
    > | b(ab)*                                                       | (ba)*b                                                       |
    > | ------------------------------------------------------------ | ------------------------------------------------------------ |
    > | L(b(ab)\*)<br/>= L(b) L((ab)\*)<br/>= L(b) (L(ab))\*<br/>= L(b) (L(a) L(b))\*<br/>= {b} {ab}\*<br/>= {b} {ε,ab,abab,ababab,...}<br/>= {ε.bab,babab,bababab,...} | L((ba)\*b)<br/>= L((ba)\*) L(b)<br/>= (L(ba))\* L(b)<br/>= (L(b) L(a))\* L(b)<br/>= {ba}\* {b}<br/>= {ε,ba,baba,bababa,...} {b}<br/>= {ε,bab,babab,bababab,...} |

- **正规式的性质**

  - |        | \|或运算              | .连接运算         |
    | ------ | --------------------- | ----------------- |
    | 交换律 | U\|V = V\|U           |                   |
    | 结合律 | U\|(V\|F) = (U\|V)\|F | U (VF) = (UV) F   |
    | 分配律 | U (V\|F) = UV\|UF     | (V\|F) U = VU\|FU |

  - Uε = εU = U

  - UV <> VU

#### 3.3.2 确定有限自动机（DFA）

#### 3.3.3 非确定有限自动机（NFA）