1. 若希望循环队列中的元素都能得到利用，则需设置一个标志域tag，并以tag的值为0或1来区分队头指针front和队尾指针rear相同时的队列状态是“空”还是"满"。试编写与此结构相应的入队和出队算法。

   > 解答：
   >
   > 在循环队列的类型结构中，增设一个tag的整型变量，进队时tag为1，出队时置tag为0（因为只有入队操作可能导致队满，也只有出队操作可能导致队空）。队列Q初始时，置tag=0、front=rear=0.这样对列的4要素如下“
   >
   > 队空条件：Q.front==Q.rear且Q.tag==0
   >
   > 队满条件：Q.front==Q.rear且Q.tag==1
   >
   > 进队操作：Q.data[rear]=x;Q.rear=(Q.rear+1)%Maxsize;Q.tag=1.
   >
   > 出队操作：x=Q.data[front];Q.front=(Q.front+1)%Maxsize;Q.tag=0
   >
   > 1. 设"tag"法的循环队列入队算法：
   >
   >    ```
   >    int EnQueue1(SqQueue &Q,ElemType x){
   >        if(Q.front==Q.rear&&Q.tag==1)
   >        return 0;   //两个条件都满足时则队满
   >          Q.data[rear]=x;
   >          Q.rear=(Q.rear+1)%Maxsize;
   >          Q.tag=1;      //可能队满
   >          return 1;
   >    }
   >    ```
   >
   > 2. 设"tag"法的循环队列出队算法：
   >
   >    ```
   >    int DeQueue1(SqQueue &Q,ElemType &x){
   >         if(Q.front==Q.rear&&Q.tag==0)
   >           return 0; //两个条件都满足时则队空
   >           x=Q.data[front];
   >           Q.front=(Q.front+1)%Maxsize;
   >           Q.tag=0;            //可能队空
   >           return 1;
   >    }
   >    ```
   >
   >    

2. Q是一个队列，S是一个空栈，实现将队列中的元素逆置的算法。

   > 解答：本题主要考查大家对队列和栈的特性与操作的理解。由于对队列的一系列操作不可能将其中的元素逆置，而栈可以将入栈的元素逆序提取出来，因此我们可以让队列中的元素逐个地出队列，入栈；全部入栈后再逐个出栈，入队列
   >
   > 算法的实现如下：
   >
   > ```
   > void Inverser(Stack S,Queue Q){
   >      //本算法实现将队列中的元素逆置
   >      while(!QueueEmpty(Q)){
   >        x=DeQueue(Q);       //队列中全部元素依次出队
   >        Push(S,x);          //元素依次入栈
   >      }
   >      whlie(!StackEmpty(S)){
   >         Pop(S,x);        //栈中全部元素依次出栈
   >         EnQueue(Q,x);    //再入队
   >      }
   > }
   > ```
   >
   > 

3. 利用两个栈S1,S2来模拟一个队列，已知栈的4个运算定义如下：

   ```
   Push(S,x);             //元素x入栈S
   Pop(S,x);               //S出栈并将出栈的值赋给x
   StackEmpty(S);          //判断栈是否为空
   StackOverflow(S);           //判断栈是否满
   ```

   如何利用栈的运算来实现该队列的3个运算（形参由读者根据要求自己设计）？

   ```
   Enqueue;          //将元素x入队
   Dequeue;          //出队，并将出队元素存储在x中
   QueueEmpty;       //判断队列是否为空
   ```

   > 解答：
   >
   > 利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入栈操作。当需要出队时，则对S2执行出栈操作。由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，而在执行此操作前必须判断S2是否为空，否则会导致顺序混乱。当栈S1和S2都为空时队列为空。
   >
   > 总结如下：
   >
   > 1. 对S2的出栈操作用作出队，若S2为空，则先将S1中的所有元素送入S2.
   >
   > 2. 对S1的入栈操作用作入队，若S1满，必须先保证S2为空，才能将S1中的元素全部插入S2中。
   >
   >    入队算法：
   >
   >    ```
   >    int EnQueue(Stack &S1,Stack &S2,ElemType e){
   >     if(!StackOverflow(S1)){
   >         Push(S1,e);
   >         return 1;
   >     }
   >     if(StackOverflow(S1)&&!StackEmpty(S2)){
   >         printf("队列满");
   >         return 0;
   >     }
   >     if(StackOverflow(S1)&&StackEmpty(S2)){
   >         while(!StackEmpty(S1)){
   >            Pop(S1,x);
   >            Push(S2,x);
   >         }
   >     }
   >     Push(S1,e);
   >     return 1;
   >    }
   >    ```
   >
   >    出队算法：
   >
   >    ```
   >    void DeQueue(Stack &S1,Stack &S2,ElemType &x){
   >        if(!StackEmpty(S2)){
   >           Pop(S2,x);
   >        }
   >        else if(StackEmpty(S1)){
   >           printf("队列为空");
   >        }
   >        else{
   >           while(!StackEmpty(S1)){
   >             Pop(S1,x);
   >             Push(S2,x);
   >           }
   >           Pop(S2,x);
   >        }
   >    }
   >    ```
   >
   >    判断队列为空的算法：
   >
   >    ```
   >    int QueueEmpty(Stack S1,Stack S2){
   >        if(StackEmpty(S1)&&StackEmpty(S2))
   >            return 1;
   >         else 
   >           return 0;
   >    }
   >    ```
   >
   >    

4. 【2019统考真题】请设计一个队列，要求满足：1. 初始时队列为空； 2. 入队时，允许增加队列占用空间；3. 出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；4. 入队操作和出队操作的时间复杂度始终保持为Q(1)。请回答下列问题：

   1. 该队列是应选择链式存储结构，还是应选择顺序存储结构？
   2. 画出队列的初始状态，并给出判断队空和队满的条件。
   3. 画出第一个元素入队后的队列状态。
   4. 给出入队操作和出队操作的基本过程。

   > 解答：
   >
   > 1. 顺序存储无法满足要求2的队列占用空间随着入队操作而增加。根据要就来分析：要求1容易满足；链式存储方便开辟新空间，要求2容易满足；对于要求3，出队后的结点并不真正释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无需开辟新空间，赋值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首尾相接的单循环链表，类似于循环队列的思想。设置队头、队尾指针后，链式队列的入队操作和出队操作的时间复杂度均为O(1),要求4可以满足。
   >
   >    因此，采用链式存储结构（两段式单向循环链表），队头指针为front,队尾指针为rear.
   >
   > 2. 该循环链式队列的实现可以参考循环队列，不同之处在于循环链式队列可以方便地增加空间，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空间结点的循环单链表，头指针front和尾指针rear均指向空闲结点，如下图所示。
   >
   >    队空的判定条件：front==rear
   >
   >    队满的判定条件：front==rear->next
   >
   > 3. 插入第一个元素后的状态如下图所示.
   >
   > 4. 操作的基本过程如下:
   >
   >    入队操作:
   >
   >    若(front==rear->next)      //队满
   >
   >       则在rear后面插入一个新的空闲结点;
   >
   >    入队元素报存到rear所指结点中;rear=rear->next;返回
   >
   >    ***
   >
   >    出队操作:
   >
   >    若(front=rear)      //队空
   >
   >       则出队失败,返回;
   >
   >    取front所指结点中的元素e;front=front->next;返回e.