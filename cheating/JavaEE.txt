
qq,1=【应用分层模型】
【1】表示层：收集用户请求并显示处理结果【2】控制层：拦截用户请求、调用业务逻辑处理请求、控制转向【3】业务逻辑层
实现业务逻辑【4】数据访问层：由 DAO（数据访问对象）组成，对数据库的增删改查...【5】数据持久层：负责数据持久化，把数据保存到数据库

qq,2=【MVC 思想及其优势】
【】数据的获取于显示分离
【】控制器将不同的模型和视图组合在一起
【】应用分为三部分：模型、视图、控制器，三部分之间松耦合并协同工作，从而提高应用的可扩展性和可维护性
【】各层负责应用的不同功能，各司其职，每一层的组件具有相同的特征，便于通过程序化和工具化产生程序代码

---------------------------------------------------------------------------------------------

ww,1=【Struts2 的处理步骤】（Struts2 处理请求直到返回响应的完整过程）（一定考）
【1】客户端浏览器发送一个请求
【2】经过核心控制器 StrutsPrepareAndExecuteFilter 过滤处理，转交给相应的 Action 代理。
qq,1=【应用分层模型】【1】表示层：收集用户请求并显示处理结果【2】控制层：拦截用户请求、调用业务逻辑处理请求、控制转向【3】业务逻辑层：实现业务逻辑【4】数据访问层：由 DAO（数据访问对象）组成，对数据库的增删改查...【5】数据持久层：负责数据持久化，把数据保存到数据库

qq,2=【MVC 思想及其优势】【】数据的获取于显示分离【】控制器将不同的模型和视图组合在一起【】应用分为三部分：模型、视图、控制器，三部分之间松耦合并协同工作，从而提高应用的可扩展性和可维护性【】各层负责应用的不同功能，各司其职，每一层的组件具有相同的特征，便于通过程序化和工具化产生程序代码

---------------------------------------------------------------------------------------------

ww,1=【Struts2 的处理步骤】（Struts2 处理请求直到返回响应的完整过程）（一定考）【1】客户端浏览器发送一个请求【2】经过核心控制器 StrutsPrepareAndExecuteFilter 过滤处理，转交给相应的 Action 代理。【3】Action 通过配置文件中的信息找到对应的 Action 类，创建 Action 对象并调用其 execute() 方法【4】调用 Action 前后，涉及相关拦截器的调用。拦截器链自动对请求应用通用功能【5】一旦 Action 执行完毕，找到 execute() 方法返回值对应的结果

ww,2=【struts2 搜索 Action 的顺序】【1】查找指定命名空间下的 Action ，如果找到则执行。【2】如果找不到，则转入到默认命名空间中查找 Action ，找到则执行。【3】如果还找不到 Action ，则 Struts2 将报错。

---------------------------------------------------------------------------------------------

ee,1=【ORM框架的优点】【1】贯彻面向对象的编程思想。 （思想）【2】减少代码的编写量，提高工作效率。 （效率）【3】提高访问数据库的性能，降低访问数据库的频率。 （性能）【4】具有相对独立性，发生变化时不会影响上层的实现。 （独立性）

ee,2=【持久化对象（PO，Persistent Object）的作用】完成持久化操作，即通过该对象可对数据库以面向对象的方式进行操作。应用程序无需直接访问数据库，只需创建、修改或删除持久化对象，Hibernate 则会负责将这些操作转换成相应的对数据库表的操作。

ee,3=【三种开发方式】【1】自底向上 数据库表 to 持久化类，根据数据库中表的结构生成对应的映射文件和持久化类【2】自顶向下 持久化类 to 数据库表，先编写持久化类，然后编写映射文件，进而生成数据库表结构【3】从中间出发，先编写映射文件，然后向上生成持久化类，向下生成数据库表结构

ee,4=【Hibernate 应用程序的开发步骤】【1】配置 Hibernate 应用环境，在应用中添加 Hibernate 所需的 jar 包，并创建 Hibernate 配置文件【2】创建持久化类及其 ORM 映射文件【3】利用 Configuration 装载配置【4】利用 SessionFactory 创建 Session【5】通过 Session 进行持久化对象的管理【6】利用 Transaction 管理事务【7】利用 Query 进行 HQL 查询 or 利用 Criteria 实现条件查询

rr,1=【持久化操作步骤】【1】创建 Configuration 并装载配置【2】创建 SessionFactory 对象【3】打开 Session【4】开始事务【5】持久化操作【6】提交事务【7】关闭 Session

rr,2=【HQL 检索】【1】获取 Hibernate 的 Session 对象Session s = HibernateUtils.getSession();【2】编写 HQL 查询语句 String hql = "";【3】以 HQL 作为参数，调用 Session 对象的 createQuery() 方法，创建 Query 对象 Query q = s.createQuery(hql);【4】如果 HQL 语句中包含参数，调用 Query 对象的 setXXX() 方法为参数赋值 query.setString("","");【5】调用 Query 对象的 list() 等方法得到查询结果 List<User> list = query.list();

rr,3=【QBC 检索】【1】获取 Hibernate 的 Session 对象【2】以某类的 Class 对象作为参数调用 Session 对象的 createCriteria() 方法，创建 Criteria 对象【3】通过调用 Criteria 对象的 add() 方法，增加 Criterion 查询条件【4】执行 Criteria 的 list() 等方法得到查询结果

---------------------------------------------------------------------------------------------

tt,1=【Spring 优势】【1】低侵入式设计，代码无污染【2】独立于各种应用服务器，真正实现 Write Once、Run Anywhere（一次编写、随处运行）的承诺【3】IoC 容器降低了业务对象替换的复杂性，降低了组件之间的耦合【4】AOP 容器允许将一些通用任务如安全、事务、日志...进行集中式处理【5】Spring 中的 ORM 和 DAO 支持提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问【6】Spring 的高度开放性，并不强制开发者完全依赖于 Spring，可自由选用 Spring 框架的部分 or 全部功能

tt,2=【依赖注入的两种格式】【1】设值注入，通过使用属性的 setter 方法注入 Bean 的属性值or依赖对象。使用设值注入要求 Bean 提供一个默认的无参构造方法，并为需要注入的属性提供对应的 setter 方法。【2】构造注入，通过使用构造来注入 Bean 的属性or依赖对象。可以确保一些必要的属性在 Bean 实例化时就得到设置，从而使 Bean 在实例化后就可以使用。

tt,3=【设值注入 优点】【1】与传统的 JavaBean 写法更相似，通过 setter 方法设定依赖关系显得更加直观、自然。【2】对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring 在创建 Bean 实例时，需要同时实例化其依赖的全部实例，因为导致性能下降，而使用设值注入则能避免这些问题。

tt,4=【构造注入 优点】【1】构造注入可以在构造器中决定依赖关系的注入顺序。优先依赖的优先注入。比如 Web 开发时使用数据库，可以优先注入数据库连接的信息。【2】对于依赖关系无需变化的 Bean，构造注入更有用处。没有 setter 方法，所有的依赖关系全部在构造器内部设定，后续代码不会对依赖关系产生破坏。依赖关系只能在构造器中设定，所以只有组件的创建者才能改变组件的依赖关系。而对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。

tt,5=【Bean 作用域】【1】singleton：在每个 Spring IoC 容器中，一个 Bean 定义对应唯一一个对象实例，Bean 以单例的方式存在【2】prototype：一个 Bean 定义对应多个对象实例，每次调用 getBean() 时，就创建一个新实例【3】request：在一次 HTTP 请求中，一个 Bean 定义对应一个实例，即每次 HTTP 请求都将会有各自的 Bean 实例【4】session：在一个 HTTP Session 中，一个 Bean 定义对应一个实例【5】global session：在一个全局的 HTTP Session 中，一个 Bean 定义对应一个实例。仅在使用 portlet context 的时候有效


====== 增加容错率 ===========================================================================================================================================



fc,1=【应用分层模型】【1】表示层：收集用户请求并显示处理结果【2】控制层：拦截用户请求、调用业务逻辑处理请求、控制转向【3】业务逻辑层：实现业务逻辑【4】数据访问层：由 DAO（数据访问对象）组成，对数据库的增删改查...【5】数据持久层：负责数据持久化，把数据保存到数据库

mvc,1=【MVC 思想及其优势】【】数据的获取于显示分离【】控制器将不同的模型和视图组合在一起【】应用分为三部分：模型、视图、控制器，三部分之间松耦合并协同工作，从而提高应用的可扩展性和可维护性【】各层负责应用的不同功能，各司其职，每一层的组件具有相同的特征，便于通过程序化和工具化产生程序代码

---------------------------------------------------------------------------------------------

st,1=【Struts2 的处理步骤】（Struts2 处理请求直到返回响应的完整过程）（一定考）【1】客户端浏览器发送一个请求【2】经过核心控制器 StrutsPrepareAndExecuteFilter 过滤处理，转交给相应的 Action 代理。【3】Action 通过配置文件中的信息找到对应的 Action 类，创建 Action 对象并调用其 execute() 方法【4】调用 Action 前后，涉及相关拦截器的调用。拦截器链自动对请求应用通用功能【5】一旦 Action 执行完毕，找到 execute() 方法返回值对应的结果

st,2=【struts2 搜索 Action 的顺序】【1】查找指定命名空间下的 Action ，如果找到则执行。【2】如果找不到，则转入到默认命名空间中查找 Action ，找到则执行。【3】如果还找不到 Action ，则 Struts2 将报错。

---------------------------------------------------------------------------------------------

orm,1=【ORM框架的优点】【1】贯彻面向对象的编程思想。 （思想）【2】减少代码的编写量，提高工作效率。 （效率）【3】提高访问数据库的性能，降低访问数据库的频率。 （性能）【4】具有相对独立性，发生变化时不会影响上层的实现。 （独立性）

cjh,1=【持久化对象（PO，Persistent Object）的作用】完成持久化操作，即通过该对象可对数据库以面向对象的方式进行操作。应用程序无需直接访问数据库，只需创建、修改或删除持久化对象，Hibernate 则会负责将这些操作转换成相应的对数据库表的操作。

kf,1=【三种开发方式】【1】自底向上 数据库表 to 持久化类，根据数据库中表的结构生成对应的映射文件和持久化类【2】自顶向下 持久化类 to 数据库表，先编写持久化类，然后编写映射文件，进而生成数据库表结构【3】从中间出发，先编写映射文件，然后向上生成持久化类，向下生成数据库表结构

hi,1=【Hibernate 应用程序的开发步骤】【1】配置 Hibernate 应用环境，在应用中添加 Hibernate 所需的 jar 包，并创建 Hibernate 配置文件【2】创建持久化类及其 ORM 映射文件【3】利用 Configuration 装载配置【4】利用 SessionFactory 创建 Session【5】通过 Session 进行持久化对象的管理【6】利用 Transaction 管理事务【7】利用 Query 进行 HQL 查询 or 利用 Criteria 实现条件查询

cjh,2=【持久化操作步骤】【1】创建 Configuration 并装载配置【2】创建 SessionFactory 对象【3】打开 Session【4】开始事务【5】持久化操作【6】提交事务【7】关闭 Session

hq,1=【HQL 检索】【1】获取 Hibernate 的 Session 对象Session s = HibernateUtils.getSession();【2】编写 HQL 查询语句 String hql = "";【3】以 HQL 作为参数，调用 Session 对象的 createQuery() 方法，创建 Query 对象 Query q = s.createQuery(hql);【4】如果 HQL 语句中包含参数，调用 Query 对象的 setXXX() 方法为参数赋值 query.setString("","");【5】调用 Query 对象的 list() 等方法得到查询结果 List<User> list = query.list();

qb,1=【QBC 检索】【1】获取 Hibernate 的 Session 对象【2】以某类的 Class 对象作为参数调用 Session 对象的 createCriteria() 方法，创建 Criteria 对象【3】通过调用 Criteria 对象的 add() 方法，增加 Criterion 查询条件【4】执行 Criteria 的 list() 等方法得到查询结果

js,1=【HQL 检索】【1】获取 Hibernate 的 Session 对象Session s = HibernateUtils.getSession();【2】编写 HQL 查询语句 String hql = "";【3】以 HQL 作为参数，调用 Session 对象的 createQuery() 方法，创建 Query 对象 Query q = s.createQuery(hql);【4】如果 HQL 语句中包含参数，调用 Query 对象的 setXXX() 方法为参数赋值 query.setString("","");【5】调用 Query 对象的 list() 等方法得到查询结果 List<User> list = query.list();

js,2=【QBC 检索】【1】获取 Hibernate 的 Session 对象【2】以某类的 Class 对象作为参数调用 Session 对象的 createCriteria() 方法，创建 Criteria 对象【3】通过调用 Criteria 对象的 add() 方法，增加 Criterion 查询条件【4】执行 Criteria 的 list() 等方法得到查询结果


---------------------------------------------------------------------------------------------

sp,1=【Spring 优势】【1】低侵入式设计，代码无污染【2】独立于各种应用服务器，真正实现 Write Once、Run Anywhere（一次编写、随处运行）的承诺【3】IoC 容器降低了业务对象替换的复杂性，降低了组件之间的耦合【4】AOP 容器允许将一些通用任务如安全、事务、日志...进行集中式处理【5】Spring 中的 ORM 和 DAO 支持提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问【6】Spring 的高度开放性，并不强制开发者完全依赖于 Spring，可自由选用 Spring 框架的部分 or 全部功能

yl,1=【依赖注入的两种格式】【1】设值注入，通过使用属性的 setter 方法注入 Bean 的属性值or依赖对象。使用设值注入要求 Bean 提供一个默认的无参构造方法，并为需要注入的属性提供对应的 setter 方法。【2】构造注入，通过使用构造来注入 Bean 的属性or依赖对象。可以确保一些必要的属性在 Bean 实例化时就得到设置，从而使 Bean 在实例化后就可以使用。

sz,1=【设值注入 优点】【1】与传统的 JavaBean 写法更相似，通过 setter 方法设定依赖关系显得更加直观、自然。【2】对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring 在创建 Bean 实例时，需要同时实例化其依赖的全部实例，因为导致性能下降，而使用设值注入则能避免这些问题。

gz,1=【构造注入 优点】【1】构造注入可以在构造器中决定依赖关系的注入顺序。优先依赖的优先注入。比如 Web 开发时使用数据库，可以优先注入数据库连接的信息。【2】对于依赖关系无需变化的 Bean，构造注入更有用处。没有 setter 方法，所有的依赖关系全部在构造器内部设定，后续代码不会对依赖关系产生破坏。依赖关系只能在构造器中设定，所以只有组件的创建者才能改变组件的依赖关系。而对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。

be,1=【Bean 作用域】【1】singleton：在每个 Spring IoC 容器中，一个 Bean 定义对应唯一一个对象实例，Bean 以单例的方式存在【2】prototype：一个 Bean 定义对应多个对象实例，每次调用 getBean() 时，就创建一个新实例【3】request：在一次 HTTP 请求中，一个 Bean 定义对应一个实例，即每次 HTTP 请求都将会有各自的 Bean 实例【4】session：在一个 HTTP Session 中，一个 Bean 定义对应一个实例【5】global session：在一个全局的 HTTP Session 中，一个 Bean 定义对应一个实例。仅在使用 portlet context 的时候有效


